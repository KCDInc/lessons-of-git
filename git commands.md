# Git commands
[Markdown cheatshett](https://github.com/adam-p/Markdown-here/wiki/Markdown-Cheatsheet)

[YAML cheatsheet](https://gist.github.com/jonschlinkert/5170877)

> gitk - view change [gitk doc](https://git-scm.com/docs/gitk)

## 1 Version control system

### Local VCS

![local vcs](img/local.png)

### centralized VCS

![cetralized](img/centralized.png)

### Distributed VCS

![distributed](img/distributed.png)

## History

Created by BitKeeper for Linux

**Golal:**

* Speed
* simple architecture
* not line development
* full distributed
* manage big project (sample Linux)

## Essential characteristics git

* all opertions executeble local
* целостность git - used SHA-1
* Git только добавляет данные
* snapshots not delta

![atom diference delta changes](img/deltas.png)

pic 4: Хранение данных как набора изменений относительно первоначальной версии каждого из файлов.

![snapshots](img/snapshots.png)

pic 5: Хранение данных как снимков проекта во времени.

* Three state

![areas](img/areas.png)

Базовый подход в работе с Git выглядит так:

1. Вы изменяете файлы в вашей рабочей директории.
2. Вы добавляете файлы в индекс, добавляя тем самым их снимки в область подготовленных файлов.
3. Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в вашу Git директорию.

========================================================================

### Git info

В состав Git’а входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git’а, а также его внешний вид. Эти параметры могут быть сохранены в трёх местах:

1. Файл `/etc/gitconfig` содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл.
2.  Файл **~/.gitconfig** или *~/.config/git/config* хранит настройки конкретного пользователя. Этот файл используется при указании параметра > [!TIP] > --global.
3. Файл config в каталоге Git’а (т.е. .git/config) в том репозитории, который вы используете в данный момент, хранит настройки конкретного репозитория.

Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config перекрывают соответствующие значения в /etc/gitconfig.
В системах семейства Windows Git ищет файл .gitconfig в каталоге $HOME (C:\Users\$USER для большинства пользователей). Кроме того, Git ищет файл /etc/gitconfig, но уже относительно корневого каталога MSys, который находится там, куда вы решили установить Git, когда запускали инсталлятор.

## 2 Local repository

### create repository
`git init` - создаёт в текущей директории новую поддиректорию с именем **.git**

`git add *.c` - add *.c files to index отслеживать

`git add -a` or `git add .` or `git add *` - add all files

`git commit -m 'initial project version'` - save changes, create snpsh    ot

## Remote repository

### clone repository
`git clone https://github.com/libgit2/libgit2 mylibgit` - create folder mylibgit and subfolder .git download all data for this repository and create (checks out) work copy last version. "clone", not "checkout" забирается (pulled) каждая версия каждого файла из истории проекта вы можете потерять часть серверных перехватчиков (server-side hooks) и т.п., но не все данные
`git push origin master`

## write changes in repository

![write changes in repository](img/lifecycle.png)

только взяли их из хранилища (checked them out)
### check status
`git status`

### track files
`git add -a`

### index change files
`git add -a` -  Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния.
Если вы изменили файл после выполнения git add, вам придётся снова выполнить git add, чтобы проиндексировать последнюю версию файла:

### short out status
`git status -s` or --short
Новые, неотслеживаемые файлы помечены ?? слева от них, файлы добавленные в отслеживаемые помечены A, отредактированные файлы помечены M и так далее. В выводе содержится два столбца - в левом указывается статус файла, а в правой модифицирован ли он после этого. К примеру в нашем выводе, файл README модифицирован в рабочей директории и не проиндексирован, файл lib/simplegit.rb модифицирован и проиндексирован. Файл Rakefile модифицирован, проиндексирован и ещё раз модифицирован, таким образом на данный момент у него есть изменения которые попадут в коммит и те которые не попадут.

### ignore files .gitignore
sample

```
*.[oa]
*~
```
**К шаблонам в файле .gitignore применяются следующие правила:**

* Пустые строки, а также строки, начинающиеся с #, игнорируются.
* Можно использовать стандартные glob шаблоны.
* Можно начать шаблон символом слэша (/) чтобы избежать рекурсии.
* Можно заканчивать шаблон символом слэша (/) для указания каталога.
* Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.

Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. Символ (*) соответствует 0 или более символам; последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (?) соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом ([0-9]), соответствуют любому символу из интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы указать на вложенные директории: a/**/z соответствует a/z, a/b/z, a/b/c/z, и так далее.

```
# no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the root TODO file, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .txt files in the doc/ directory
doc/**/*.txt
```

[.gitignore template on github](https://github.com/github/gitignore )

### view index and not index changes

`git diff` - что вы изменили, но ещё не проиндексировали, и `git diff --staged` что вы проиндексировали и собираетесь фиксировать (--staged и --cached синонимы). показывает вам непосредственно добавленные и удалённые строки — собственно заплатку (patch).
Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите git diff без аргументов:Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.
Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить `git diff --staged` or `--cached`. Эта команда сравнивает ваши индексированные изменения с последним коммитом:

`git difftool --tool-help` - просмотр внешних утилит сравнения таких программ как Araxis, emerge, vimdiff

### commit changes

`git commit -v` Запомните, что коммит сохраняет снимок состояния вашего индекса. Всё, что вы не проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё один коммит

### index ignore

`git commit -a` - заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add:

### remove files

`git rm` - удаляет из индекса, также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите его как “неотслеживаемый”. Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции ``Changes not staged for commit`` (измененные, но не проиндексированные) Затем, если вы выполните команду git rm, удаление файла попадёт в индекс:
После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра -f. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.
Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть оставить файл на жёстком диске, и убрать его из-под бдительного ока Git. Это особенно полезно, если вы забыли добавить что-то в файл .gitignore и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию --cached:

`git rm --cached README`
В команду git rm можно передавать файлы, каталоги или glob-шаблоны. Это означает, что вы можете вытворять что-то вроде:

`git rm log/\*.log`
Обратите внимание на обратный слэш (\) перед *. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора. Эта команда удаляет все файлы имеющие расширение .log находящиеся в директории log/. Или же вы можете сделать вот так:

`git rm \*~` Эта команда удаляет все файлы, чьи имена заканчиваются на ~.

### move files

`git mv file_from file_to` - rename file
Однако, это эквивалентно выполнению следующих команд:

```
mv README.md README
git rm README.md
git add README
```

Единственное отличие состоит лишь в том, что mv — это одна команда вместо трёх — это функция для удобства

## history commit

### view history

`git log -p -2` - list commit for code review

`git log --stat` - short stat for every commit

`git log --pretty=oneline` - every commit in one line

> short, full and fuller

command log option --pretty

`git log --pretty=format:"%h - %an, %ar : %s"`

Table 1. Полезные опции для git log --pretty=format

|option  |disription out  |
|---------|---------|
|%H   |Хеш коммита|
|%h     |Сокращенный хеш коммита|
|%T     |Хеш дерева|
|%t     |Сокращенный хеш дерева|
|%P     |Хеш родителей|
|%p     |Сокращенный хеш родителей|
|%an     |Имя автора|
|%ae     |Электронная почта автора|
|%ad     |Дата автора (формат даты можно задать опцией --date=option)|
|%ar     |Относительная дата автора|
|%cn     |Имя коммитера|
|%ce     |Электронная почта коммитера|
|%cd     |Дата коммитера|
|%cr     |Относительная дата коммитера|
|%s     |Содержание|

Автор – это человек, изначально сделавший работу, а коммитер – это человек, который последним применил эту работу. Другими словами, если вы создадите патч для какого-то проекта, а один из основных членов команды этого проекта применит этот патч, вы оба получите статус участника – вы как автор и основной член команды как коммитер.

`git log --pretty=format:"%h %s" --graph` - показывает текущую ветку и историю слияний

Table 2. Наиболее распространенные опции для команды git log

|option  |description  |
|------------------|---------|
|-p     |Показывает патч для каждого коммита.|
|--stat     |Показывает статистику измененных файлов для каждого коммита.|
|--shortstat     |Отображает только строку с количеством изменений/вставок/удалений для команды --stat.|
|--name-only|Показывает список измененных файлов после информации о коммите.|
|--name-status     |Показывает список файлов, которые добавлены/изменены/удалены.|
|--abbrev-commit     |Показывает только несколько символов SHA-1 чек-суммы вместо всех 40.|
|--relative-date     |Отображает дату в относительном формате (например, "2 weeks ago") вместо стандартного формата даты.|
|--graph     |Отображает ASCII граф с ветвлениями и историей слияний.|
|--pretty     |Показывает коммиты в альтернативном формате. Возможные варианты опций: oneline, short, full, fuller и format (с помощью последней опции вы можете указать свой формат).|

### Limitation out (filters)

`git log --since=2.weeks` - покажет список коммитов, сделанных за последние две недели. Это команда работает с большим количеством форматов – вы можете указать определенную дату вида "2008-01-15" или же относительную дату, например "2 years 1 day 3 minutes ago" Также вы можете фильтровать список коммитов, которые удовлетворяют каким-то критериям. Опция --author дает возможность фильтровать по автору коммита, а опция --grep искать по ключевым словам в сообщении коммита. (Имейте ввиду, что если вы хотите фильтровать коммиты по автору и ключевым словам одновременно, вам нужно также добавить --all-match. В противном случае, команда отфильтрует вывод по одному из двух критериев.)

`git log -Sfunction_name` - принимает строку и показывает только те коммиты, в которых изменение в коде повлекло за собой добавление или удаление этой строки. Например, если вы хотите найти последний коммит, который добавил или удалил вызов определенной функции, вы можете запустить команду

Последней полезной опцией, которую принимает команда git log как фильтр, является путь. Если вы укажете директорию или имя файла, вы ограничите вывод только теми коммитами, в которых были изменения этих файлов. Эта опция всегда указывается последней после двойного тире (--), что отделяет указываемый путь от опций.

*Table 3. Опции для ограничения вывода команды git log*

|option  |description  |
|---------|---------|
|-(n)     |Показывает только последние n коммитов.|
|--since, --after     |Показывает только те коммиты, которые были сделаны после указанной даты.|
|--until, --before     |Показывает только те коммиты, которые были сделаны до указанной даты.|
|--author     |Показывает только те коммиты, в которых запись author совпадает с указанной строкой.|
|--committer     |Показывает только те коммиты, в которых запись committer совпадает с указанной строкой.|
|--grep     |Показывает только коммиты, сообщение которых содержит указанную строку.|
|-S     |Показывает только коммиты, в которых изменение в коде повлекло за собой добавление или удаление указанной строки.|

Например, если вы хотите увидеть, в каких коммитах произошли изменения в тестовых файлах в истории исходного кода Git, автором которых был Junio Hamano и которые не были слияниями в октябре 2008 года, вы можете запустить следующую команду:

```
git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \
--before="2008-11-01" --no-merges -- t/
```

Из почти 40,000 коммитов в истории исходного кода Git, эта команда показывает только 6, которые соответствуют этим критериям.

## Undo operation

Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит, можно запустить commit с параметром --amend (дополнить):

`git commit --amend`

Например, если вы фиксируете изменения, и понимаете, что забыли проиндексировать изменения в файле, который хотели включить в коммит, можно сделать примерно так:

```
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
```

### undo prepare file

области подготовки (staging area) и рабочего каталог.

Например, скажем, вы изменили два файла, и хотите закоммитить их двумя раздельными изменениями, но случайно набрали git add *, и добавили оба в индекс.

`git reset HEAD CONTRIBUTING.md` - отменим индексирование файла CONTRIBUTING.md

> Хотя git reset может стать опасной командой, если ее вызвать с --hard, в приведенном примере файл в вашем рабочем каталоге не затрагивается. Вызов git reset без параметра не опасен — он затрагивает только область подготовки.

### undo changes changed file

Что делать, если вы поняли, что не хотите сохранять свои изменения файла CONTRIBUTING.md? Как можно просто «разызменить» его — вернуть к тому виду, который был в последнем коммите

`git checkout -- CONTRIBUTING.md`

> Важно понимать, что git checkout -- [file] — опасная команда. Любые изменения соответствующего файла пропадают — вы просто копируете поверх него другой файл. Ни в коем случае не используйте эту команду, если вы не убеждены, что файл вам не нужен.

Если вы хотите сохранить изменения файла, но пока отложить их в сторону, давайте пройдемся по тому, как прятать (stash) и создавать ветки (branch) в Ветвление в Git; эти способы обычно лучше.

Помните, все, что зафиксировано коммитом в Git, почти всегда можно восстановить. Можно восстановить даже коммиты, сделанные в удаленных ветках, или коммиты, замещенные параметром --amend (см. Восстановление данных). Но все, что вы потеряете, не сделав коммит, скорее всего, вам больше не увидеть.

## Work with remote repositorie
Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. 

### view remote repo
```
$ git clone https://github.com/schacon/ticgit
$ cd ticgit
$ git remote
```

`git remote -v` - detailed view address for read and write

### add remote repo

`git remote add pb https://github.com/paulboone/ticgit`

если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду : `git fetch pb` Ветка master из репозитория Пола сейчас доступна вам под именем pb/master. Вы можете слить её с одной из ваших веток или переключить на неё локальную ветку, чтобы просмотреть содержимое ветки Пола

### get changes from remote repo

`git fetch [remote-name]`

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем “origin”. Таким образом, *git fetch origin* извлекает все наработки, отправленные (push) на этот сервер после того, как вы склонировали его (или получили изменения с помощью fetch). Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Если у вас есть ветка, настроенная на отслеживание удалённой ветки то, Выполнение *git pull*, как правило, извлекает (fetch) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

### send changes to remote repo
Когда вы хотите поделиться своими наработками, вам необходимо отправить (push) их в главный репозиторий. *git push [remote-name] [branch-name]*

`git push origin master` - Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Иначе Вам придётся сначала вытянуть (pull) их изменения и объединить с вашими. Только после этого вам будет позволено выполнить push.

### View remote repo
`git remote show origin` - Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках.

```
$ git remote show origin
* remote origin
  URL: https://github.com/my-org/complex-project
  Fetch URL: https://github.com/my-org/complex-project
  Push  URL: https://github.com/my-org/complex-project
  HEAD branch: master
  Remote branches:
    master                           tracked
    dev-branch                       tracked
    markdown-strip                   tracked
    issue-43                         new (next fetch will store in remotes/origin)
    issue-45                         new (next fetch will store in remotes/origin)
    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)
  Local branches configured for 'git pull':
    dev-branch merges with remote dev-branch
    master     merges with remote master
  Local refs configured for 'git push':
    dev-branch                     pushes to dev-branch                     (up to date)
    markdown-strip                 pushes to markdown-strip                 (up to date)
    master                         pushes to master                         (up to date)
```

Данная команда показывает какая именно локальная ветка будет отправлена на удалённый сервер по умолчанию при выполнении git push. Она также показывает, каких веток с удалённого сервера у вас ещё нет, какие ветки всё ещё есть у вас, но уже удалены на сервере. И для нескольких веток показано, какие удалённые ветки будут в них влиты при выполнении git pull.

### remove and rename remote repo

`git remote rename pb paul` - это также меняет для вас имена удалённых веток. То, к чему вы обращались как pb/master, теперь стало paul/master.

`git remote rm paul` - удалить ссылку

## work with tag
возможность помечать (tag) определённые моменты в истории как важные. Как правило, эта функциональность используется для отметки моментов выпуска версий (v1.0, и т.п.)

### view tags

`git tag` - Данная команда перечисляет метки в алфавитном порядке

Для меток вы также можете осуществлять поиск по шаблону. Например, репозиторий Git’а содержит более 500 меток. Если вас интересует просмотр только выпусков 1.8.5, вы можете выполнить следующее:
`git tag -l 'v1.8.5*'`

### create tag

Git использует два основных типа меток: легковесные и аннотированные.
Легковесная метка — это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит. В сущности, это контрольная сумма коммита, сохранённая в файл Для создания легковесной метки не передавайте опций -a, -s и -m

А вот аннотированные метки хранятся в базе данных Git’а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG). Обычно рекомендуется создавать аннотированные метки, чтобы иметь всю перечисленную информацию; но если вы хотите сделать временную метку или по какой-то причине не хотите сохранять остальную информацию, то для этого годятся и легковесные метки.

`git tag -a v1.4 -m 'my version 1.4'` - Создание аннотированной метки Опция -m задаёт сообщение метки, которое будет храниться вместе с меткой

Вы можете посмотреть данные метки вместе с коммитом, который был помечен, с помощью команды git show: `git show v1.4`

`git tag v1.4-lw` - На этот раз при выполнении git show на этой метке вы не увидите дополнительной информации. Команда просто покажет помеченный коммит: `git show v1.4-lw`

### Tagging later

Также возможно помечать уже пройденные коммиты. Предположим, что история коммитов выглядит следующим образом:

```
$ git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme
```

Теперь предположим, что вы забыли отметить версию проекта v1.2, которая была там, где находится коммит “updated rakefile”. Вы можете добавить метку и позже. Для отметки коммита укажите его контрольную сумму (или её часть) в конце команды:
`git tag -a v1.2 9fceb02`

### Label Exchange

По умолчанию, команда git push не отправляет метки на удалённые серверы. Необходимо явно отправить (push) метки на общий сервер после того, как вы их создали. Это делается так же, как и добавление в репозиторий для совместного использования удалённых веток — нужно выполнить git push origin [имя метки].

`git push origin v1.5`

Если у вас есть много меток, которые хотелось бы отправить все за один раз, можно использовать опцию --tags для команды git push. В таком случае все ваши метки отправятся на удалённый сервер (если только их уже там нет).

`git push origin --tags`

### Move to a label

В действительности вы не можете переходить на метки в Git, поскольку они не могут быть перемещены. Если вы хотите установить версию вашего репозитория в рабочую директорию, которая выглядит, как определенная метка, вы можете создать новую ветку с определенной меткой:
`git checkout -b version2 v2.0.0`

> Конечно, если вы так делаете и коммитите, ваша ветка version2 будет немного отличаться от вашей метки v2.0.0, поскольку она будет двигаться вперед с новыми изменениями, так что будьте осторожны.

## Aliases

Если вы не хотите печатать каждую команду для Git’а целиком, вы легко можете настроить псевдонимы (alias) для любой команды с помощью git config. Вот несколько примеров псевдонимов, которые вы, возможно, захотите задать:
```
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
```

Это означает, что, например, вместо ввода git commit, вам достаточно набрать только git ci. 

Например, чтобы исправить неудобство, с которым мы столкнулись при исключении файла из индекса, можно добавить в Git свой собственный псевдоним unstage:
`git config --global alias.unstage 'reset HEAD --'`

Это делает эквивалентными следующие две команды:
```
git unstage fileA
git reset HEAD -- fileA
```

Такой вариант кажется немного более понятным. Также, обычно, добавляют команду last следующим образом:
`git config --global alias.last 'log -1 HEAD'`

Таким образом, можно легко просмотреть последний коммит:

```
git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel <dreamer3@example.com>
Date:   Tue Aug 26 19:48:51 2008 +0800

    test for current head

    Signed-off-by: Scott Chacon <schacon@example.com>
```

Однако, возможно, вы захотите выполнить внешнюю команду, а не подкоманду Git’а. В этом случае, следует начать команду с символа !. Это полезно, если вы пишете свои утилиты для работы с Git-репозиторием. Продемонстрируем этот случай на примере создания псевдонима git visual для запуска gitk:
`git config --global alias.visual "!gitk"`

все базовые локальные операции с Git’ом: создавать или клонировать репозиторий, вносить изменения, индексировать и фиксировать эти изменения, а также просматривать историю всех изменений в репозитории

## 3 Branching 