# Git commands
[Markdown cheatshett](https://github.com/adam-p/Markdown-here/wiki/Markdown-Cheatsheet)

[YAML cheatsheet](https://gist.github.com/jonschlinkert/5170877)

> gitk - view change [gitk doc](https://git-scm.com/docs/gitk)

## Version control system

### Local VCS

![local vcs](img/local.png)

### centralized VCS

![cetralized](img/centralized.png)

### Distributed VCS

![distributed](img/distributed.png)

## History

Created by BitKeeper for Linux

**Golal:**

* Speed
* simple architecture
* not line development
* full distributed
* manage big project (sample Linux)

## Essential characteristics git

* all opertions executeble local
* целостность git - used SHA-1
* Git только добавляет данные
* snapshots not delta

![atom diference delta changes](img/deltas.png)

pic 4: Хранение данных как набора изменений относительно первоначальной версии каждого из файлов.

![snapshots](img/snapshots.png)

pic 5: Хранение данных как снимков проекта во времени.

* Three state

![areas](img/areas.png)

Базовый подход в работе с Git выглядит так:

1. Вы изменяете файлы в вашей рабочей директории.
2. Вы добавляете файлы в индекс, добавляя тем самым их снимки в область подготовленных файлов.
3. Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в вашу Git директорию.

========================================================================

## Git

В состав Git’а входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git’а, а также его внешний вид. Эти параметры могут быть сохранены в трёх местах:

1. Файл `/etc/gitconfig` содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл.
2.  Файл **~/.gitconfig** или *~/.config/git/config* хранит настройки конкретного пользователя. Этот файл используется при указании параметра > [!TIP] > --global.
3. Файл config в каталоге Git’а (т.е. .git/config) в том репозитории, который вы используете в данный момент, хранит настройки конкретного репозитория.

Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config перекрывают соответствующие значения в /etc/gitconfig.
В системах семейства Windows Git ищет файл .gitconfig в каталоге $HOME (C:\Users\$USER для большинства пользователей). Кроме того, Git ищет файл /etc/gitconfig, но уже относительно корневого каталога MSys, который находится там, куда вы решили установить Git, когда запускали инсталлятор.

## Local repository

### create repository
`git init` - создаёт в текущей директории новую поддиректорию с именем **.git**

`git add *.c` - add *.c files to index отслеживать

`git add -a` or `git add .` or `git add *` - add all files

`git commit -m 'initial project version'` - save changes, create snpsh    ot

## Remote repository

### clone repository
`git clone https://github.com/libgit2/libgit2 mylibgit` - create folder mylibgit and subfolder .git download all data for this repository and create (checks out) work copy last version. "clone", not "checkout" забирается (pulled) каждая версия каждого файла из истории проекта вы можете потерять часть серверных перехватчиков (server-side hooks) и т.п., но не все данные
`git push origin master`

## write changes in repository

![write changes in repository](img/lifecycle.png)

только взяли их из хранилища (checked them out)
### check status
`git status`

### track files
`git add -a`

### index change files
`git add -a` -  Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния.
Если вы изменили файл после выполнения git add, вам придётся снова выполнить git add, чтобы проиндексировать последнюю версию файла:

### short out status
`git status -s` or --short
Новые, неотслеживаемые файлы помечены ?? слева от них, файлы добавленные в отслеживаемые помечены A, отредактированные файлы помечены M и так далее. В выводе содержится два столбца - в левом указывается статус файла, а в правой модифицирован ли он после этого. К примеру в нашем выводе, файл README модифицирован в рабочей директории и не проиндексирован, файл lib/simplegit.rb модифицирован и проиндексирован. Файл Rakefile модифицирован, проиндексирован и ещё раз модифицирован, таким образом на данный момент у него есть изменения которые попадут в коммит и те которые не попадут.

### ignore files .gitignore
sample

```
*.[oa]
*~
```
**К шаблонам в файле .gitignore применяются следующие правила:**

* Пустые строки, а также строки, начинающиеся с #, игнорируются.
* Можно использовать стандартные glob шаблоны.
* Можно начать шаблон символом слэша (/) чтобы избежать рекурсии.
* Можно заканчивать шаблон символом слэша (/) для указания каталога.
* Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.

Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. Символ (*) соответствует 0 или более символам; последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (?) соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом ([0-9]), соответствуют любому символу из интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы указать на вложенные директории: a/**/z соответствует a/z, a/b/z, a/b/c/z, и так далее.

```
# no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the root TODO file, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .txt files in the doc/ directory
doc/**/*.txt
```

[.gitignore template on github](https://github.com/github/gitignore )

### view index and not index changes

`git diff` - что вы изменили, но ещё не проиндексировали, и `git diff --staged` что вы проиндексировали и собираетесь фиксировать (--staged и --cached синонимы). показывает вам непосредственно добавленные и удалённые строки — собственно заплатку (patch).
Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите git diff без аргументов:Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.
Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить `git diff --staged` or `--cached`. Эта команда сравнивает ваши индексированные изменения с последним коммитом:

`git difftool --tool-help` - просмотр внешних утилит сравнения таких программ как Araxis, emerge, vimdiff

### commit changes

`git commit -v` Запомните, что коммит сохраняет снимок состояния вашего индекса. Всё, что вы не проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё один коммит

### index ignore

`git commit -a` - заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add:

### remove files

`git rm` - удаляет из индекса, также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите его как “неотслеживаемый”. Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции ``Changes not staged for commit`` (измененные, но не проиндексированные) Затем, если вы выполните команду git rm, удаление файла попадёт в индекс:
После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра -f. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.
Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть оставить файл на жёстком диске, и убрать его из-под бдительного ока Git. Это особенно полезно, если вы забыли добавить что-то в файл .gitignore и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию --cached:

`git rm --cached README`
В команду git rm можно передавать файлы, каталоги или glob-шаблоны. Это означает, что вы можете вытворять что-то вроде:

`git rm log/\*.log`
Обратите внимание на обратный слэш (\) перед *. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора. Эта команда удаляет все файлы имеющие расширение .log находящиеся в директории log/. Или же вы можете сделать вот так:

`git rm \*~` Эта команда удаляет все файлы, чьи имена заканчиваются на ~.

### move files

`git mv file_from file_to` - rename file
Однако, это эквивалентно выполнению следующих команд:

```
mv README.md README
git rm README.md
git add README
```

Единственное отличие состоит лишь в том, что mv — это одна команда вместо трёх — это функция для удобства

## history commit

### view history

`git log -p -2` - list commit for code review

`git log --stat` - short stat for every commit

`git log --pretty=oneline` - every commit in one line

> short, full and fuller

command log option --pretty

`git log --pretty=format:"%h - %an, %ar : %s"`

Table 1. Полезные опции для git log --pretty=format

|option  |disription out  |
|---------|---------|
|%H   |Хеш коммита|
|%h     |Сокращенный хеш коммита|
|%T     |Хеш дерева|
|%t     |Сокращенный хеш дерева|
|%P     |Хеш родителей|
|%p     |Сокращенный хеш родителей|
|%an     |Имя автора|
|%ae     |Электронная почта автора|
|%ad     |Дата автора (формат даты можно задать опцией --date=option)|
|%ar     |Относительная дата автора|
|%cn     |Имя коммитера|
|%ce     |Электронная почта коммитера|
|%cd     |Дата коммитера|
|%cr     |Относительная дата коммитера|
|%s     |Содержание|

Автор – это человек, изначально сделавший работу, а коммитер – это человек, который последним применил эту работу. Другими словами, если вы создадите патч для какого-то проекта, а один из основных членов команды этого проекта применит этот патч, вы оба получите статус участника – вы как автор и основной член команды как коммитер.

`git log --pretty=format:"%h %s" --graph` - показывает текущую ветку и историю слияний

Table 2. Наиболее распространенные опции для команды git log

|option  |description  |
|------------------|---------|
|-p     |Показывает патч для каждого коммита.|
|--stat     |Показывает статистику измененных файлов для каждого коммита.|
|--shortstat     |Отображает только строку с количеством изменений/вставок/удалений для команды --stat.|
|--name-only|Показывает список измененных файлов после информации о коммите.|
|--name-status     |Показывает список файлов, которые добавлены/изменены/удалены.|
|--abbrev-commit     |Показывает только несколько символов SHA-1 чек-суммы вместо всех 40.|
|--relative-date     |Отображает дату в относительном формате (например, "2 weeks ago") вместо стандартного формата даты.|
|--graph     |Отображает ASCII граф с ветвлениями и историей слияний.|
|--pretty     |Показывает коммиты в альтернативном формате. Возможные варианты опций: oneline, short, full, fuller и format (с помощью последней опции вы можете указать свой формат).|

### Limitation out (filters)

`git log --since=2.weeks` - покажет список коммитов, сделанных за последние две недели. Это команда работает с большим количеством форматов – вы можете указать определенную дату вида "2008-01-15" или же относительную дату, например "2 years 1 day 3 minutes ago" Также вы можете фильтровать список коммитов, которые удовлетворяют каким-то критериям. Опция --author дает возможность фильтровать по автору коммита, а опция --grep искать по ключевым словам в сообщении коммита. (Имейте ввиду, что если вы хотите фильтровать коммиты по автору и ключевым словам одновременно, вам нужно также добавить --all-match. В противном случае, команда отфильтрует вывод по одному из двух критериев.)

`git log -Sfunction_name` - принимает строку и показывает только те коммиты, в которых изменение в коде повлекло за собой добавление или удаление этой строки. Например, если вы хотите найти последний коммит, который добавил или удалил вызов определенной функции, вы можете запустить команду

Последней полезной опцией, которую принимает команда git log как фильтр, является путь. Если вы укажете директорию или имя файла, вы ограничите вывод только теми коммитами, в которых были изменения этих файлов. Эта опция всегда указывается последней после двойного тире (--), что отделяет указываемый путь от опций.

*Table 3. Опции для ограничения вывода команды git log*

|option  |description  |
|---------|---------|
|-(n)     |Показывает только последние n коммитов.|
|--since, --after     |Показывает только те коммиты, которые были сделаны после указанной даты.|
|--until, --before     |Показывает только те коммиты, которые были сделаны до указанной даты.|
|--author     |Показывает только те коммиты, в которых запись author совпадает с указанной строкой.|
|--committer     |Показывает только те коммиты, в которых запись committer совпадает с указанной строкой.|
|--grep     |Показывает только коммиты, сообщение которых содержит указанную строку.|
|-S     |Показывает только коммиты, в которых изменение в коде повлекло за собой добавление или удаление указанной строки.|

Например, если вы хотите увидеть, в каких коммитах произошли изменения в тестовых файлах в истории исходного кода Git, автором которых был Junio Hamano и которые не были слияниями в октябре 2008 года, вы можете запустить следующую команду:

```
git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \
--before="2008-11-01" --no-merges -- t/
```

Из почти 40,000 коммитов в истории исходного кода Git, эта команда показывает только 6, которые соответствуют этим критериям.

## Undo operation

Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит, можно запустить commit с параметром --amend (дополнить):

`git commit --amend`

Например, если вы фиксируете изменения, и понимаете, что забыли проиндексировать изменения в файле, который хотели включить в коммит, можно сделать примерно так:

```
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
```

### undo prepare file

области подготовки (staging area) и рабочего каталог.

Например, скажем, вы изменили два файла, и хотите закоммитить их двумя раздельными изменениями, но случайно набрали git add *, и добавили оба в индекс.

`git reset HEAD CONTRIBUTING.md` - отменим индексирование файла CONTRIBUTING.md

> Хотя git reset может стать опасной командой, если ее вызвать с --hard, в приведенном примере файл в вашем рабочем каталоге не затрагивается. Вызов git reset без параметра не опасен — он затрагивает только область подготовки.

### undo changes changed file

Что делать, если вы поняли, что не хотите сохранять свои изменения файла CONTRIBUTING.md? Как можно просто «разызменить» его — вернуть к тому виду, который был в последнем коммите

`git checkout -- CONTRIBUTING.md`

> Важно понимать, что git checkout -- [file] — опасная команда. Любые изменения соответствующего файла пропадают — вы просто копируете поверх него другой файл. Ни в коем случае не используйте эту команду, если вы не убеждены, что файл вам не нужен.

Если вы хотите сохранить изменения файла, но пока отложить их в сторону, давайте пройдемся по тому, как прятать (stash) и создавать ветки (branch) в Ветвление в Git; эти способы обычно лучше.

Помните, все, что зафиксировано коммитом в Git, почти всегда можно восстановить. Можно восстановить даже коммиты, сделанные в удаленных ветках, или коммиты, замещенные параметром --amend (см. Восстановление данных). Но все, что вы потеряете, не сделав коммит, скорее всего, вам больше не увидеть.