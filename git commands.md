# Git commands
[Markdown cheatshett](https://github.com/adam-p/Markdown-here/wiki/Markdown-Cheatsheet)

[YAML cheatsheet](https://gist.github.com/jonschlinkert/5170877)

В состав Git’а входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git’а, а также его внешний вид. Эти параметры могут быть сохранены в трёх местах:
1. Файл `/etc/gitconfig` содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл.
2. Файл **~/.gitconfig** или *~/.config/git/config* хранит настройки конкретного пользователя. Этот файл используется при указании параметра > [!TIP]
> --global.
3. Файл config в каталоге Git’а (т.е. .git/config) в том репозитории, который вы используете в данный момент, хранит настройки конкретного репозитория.

Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config перекрывают соответствующие значения в /etc/gitconfig.
В системах семейства Windows Git ищет файл .gitconfig в каталоге $HOME (C:\Users\$USER для большинства пользователей). Кроме того, Git ищет файл /etc/gitconfig, но уже относительно корневого каталога MSys, который находится там, куда вы решили установить Git, когда запускали инсталлятор.

## Local repository
### create repository
`git init` - создаёт в текущей директории новую поддиректорию с именем **.git**

`git add *.c` - add *.c files to index отслеживать

`git add -a` - add all files

`git commit -m 'initial project version'` - save changes, create snpsh    ot

## Remote repository
### clone repository
`git clone https://github.com/libgit2/libgit2 mylibgit` - create folder mylibgit and subfolder .git download all data for this repository and create (checks out) work copy last version. "clone", not "checkout" забирается (pulled) каждая версия каждого файла из истории проекта вы можете потерять часть серверных перехватчиков (server-side hooks) и т.п., но не все данные
`git push origin master`

## write changes in repository
только взяли их из хранилища (checked them out)
### check status
`git status`
### track files
`git add -a`
### index change files
`git add -a` -  Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния.
Если вы изменили файл после выполнения git add, вам придётся снова выполнить git add, чтобы проиндексировать последнюю версию файла:
### short out status
`git status -s` or --short
Новые, неотслеживаемые файлы помечены ?? слева от них, файлы добавленные в отслеживаемые помечены A, отредактированные файлы помечены M и так далее. В выводе содержится два столбца - в левом указывается статус файла, а в правой модифицирован ли он после этого. К примеру в нашем выводе, файл README модифицирован в рабочей директории и не проиндексирован, файл lib/simplegit.rb модифицирован и проиндексирован. Файл Rakefile модифицирован, проиндексирован и ещё раз модифицирован, таким образом на данный момент у него есть изменения которые попадут в коммит и те которые не попадут.
### ignore files .gitignore
sample

```
*.[oa]
*~
```
Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. Символ (*) соответствует 0 или более символам; последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (?) соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом ([0-9]), соответствуют любому символу из интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы указать на вложенные директории: a/**/z соответствует a/z, a/b/z, a/b/c/z, и так далее.
```
# no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the root TODO file, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .txt files in the doc/ directory
doc/**/*.txt
```
[.gitignore template on github](https://github.com/github/gitignore )

### view index and not index changes
`git diff` - что вы изменили, но ещё не проиндексировали, и `git diff --staged` что вы проиндексировали и собираетесь фиксировать (--staged и --cached синонимы). показывает вам непосредственно добавленные и удалённые строки — собственно заплатку (patch).
Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите git diff без аргументов:Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.
Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить `git diff --staged`. Эта команда сравнивает ваши индексированные изменения с последним коммитом:
`git difftool --tool-help` - просмотр внешних утилит сравнения таких программ как Araxis, emerge, vimdiff
### commit changes
`git commit -v` Запомните, что коммит сохраняет снимок состояния вашего индекса. Всё, что вы не проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё один коммит
### index ignore
`git commit -a` - заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add:
### remove files
`git rm` - удаляет из индекса, также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите его как “неотслеживаемый”. Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции ``Changes not staged for commit`` (измененные, но не проиндексированные) Затем, если вы выполните команду git rm, удаление файла попадёт в индекс:
После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра -f. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.
Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть оставить файл на жёстком диске, и убрать его из-под бдительного ока Git. Это особенно полезно, если вы забыли добавить что-то в файл .gitignore и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию --cached:
`git rm --cached README`
В команду git rm можно передавать файлы, каталоги или glob-шаблоны. Это означает, что вы можете вытворять что-то вроде:
`git rm log/\*.log`
Обратите внимание на обратный слэш (\) перед *. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора. Эта команда удаляет все файлы имеющие расширение .log находящиеся в директории log/. Или же вы можете сделать вот так:
`git rm \*~` Эта команда удаляет все файлы, чьи имена заканчиваются на ~.
### move files
`git mv file_from file_to` - rename file
Однако, это эквивалентно выполнению следующих команд:
```
mv README.md README
git rm README.md
git add README
```
Единственное отличие состоит лишь в том, что mv — это одна команда вместо трёх — это функция для удобства
