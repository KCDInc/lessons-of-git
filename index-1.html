<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Unknown </title></head><body>
<h1 id="git-commands">Git commands</h1>
<p><a href="https://github.com/adam-p/Markdown-here/wiki/Markdown-Cheatsheet">Markdown cheatshett</a></p>
<p><a href="https://gist.github.com/jonschlinkert/5170877">YAML cheatsheet</a></p>
<blockquote>
<p>gitk - view change <a href="https://git-scm.com/docs/gitk">gitk doc</a></p>
</blockquote>
<h2 id="1-version-control-system">1 Version control system</h2>
<h3 id="local-vcs">Local VCS</h3>
<p><img alt="local vcs" src="img/local.png" /></p>
<h3 id="centralized-vcs">centralized VCS</h3>
<p><img alt="cetralized" src="img/centralized.png" /></p>
<h3 id="distributed-vcs">Distributed VCS</h3>
<p><img alt="distributed" src="img/distributed.png" /></p>
<h2 id="history">History</h2>
<p>Created by BitKeeper for Linux</p>
<p><strong>Golal:</strong></p>
<ul>
<li>Speed</li>
<li>simple architecture</li>
<li>not line development</li>
<li>full distributed</li>
<li>manage big project (sample Linux)</li>
</ul>
<h2 id="essential-characteristics-git">Essential characteristics git</h2>
<ul>
<li>all opertions executeble local</li>
<li>целостность git - used SHA-1</li>
<li>Git только добавляет данные</li>
<li>snapshots not delta</li>
</ul>
<p><img alt="atom diference delta changes" src="img/deltas.png" /></p>
<p>pic 4: Хранение данных как набора изменений относительно первоначальной версии каждого из файлов.</p>
<p><img alt="snapshots" src="img/snapshots.png" /></p>
<p>pic 5: Хранение данных как снимков проекта во времени.</p>
<ul>
<li>Three state</li>
</ul>
<p><img alt="areas" src="img/areas.png" /></p>
<p>pic 6: Базовый подход в работе с Git</p>
<p>Базовый подход в работе с Git выглядит так:</p>
<ol>
<li>Вы изменяете файлы в вашей рабочей директории.</li>
<li>Вы добавляете файлы в индекс, добавляя тем самым их снимки в область подготовленных файлов.</li>
<li>Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в вашу Git директорию.</li>
</ol>
<p>========================================================================</p>
<h3 id="git-info">Git info</h3>
<p>В состав Git’а входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git’а, а также его внешний вид. Эти параметры могут быть сохранены в трёх местах:</p>
<ol>
<li>Файл <code>/etc/gitconfig</code> содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл.</li>
<li>Файл <strong>~/.gitconfig</strong> или <em>~/.config/git/config</em> хранит настройки конкретного пользователя. Этот файл используется при указании параметра &gt; [!TIP] &gt; --global.</li>
<li>Файл config в каталоге Git’а (т.е. .git/config) в том репозитории, который вы используете в данный момент, хранит настройки конкретного репозитория.</li>
</ol>
<p>Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config перекрывают соответствующие значения в /etc/gitconfig.
В системах семейства Windows Git ищет файл .gitconfig в каталоге $HOME (C:\Users\$USER для большинства пользователей). Кроме того, Git ищет файл /etc/gitconfig, но уже относительно корневого каталога MSys, который находится там, куда вы решили установить Git, когда запускали инсталлятор.</p>
<h2 id="2-local-repository">2 Local repository</h2>
<h3 id="create-repository">create repository</h3>
<p><code>git init</code> - создаёт в текущей директории новую поддиректорию с именем <strong>.git</strong></p>
<p><code>git add *.c</code> - add *.c files to index отслеживать</p>
<p><code>git add -a</code> or <code>git add .</code> or <code>git add *</code> - add all files</p>
<p><code>git commit -m 'initial project version'</code> - save changes, create snpsh    ot</p>
<h2 id="remote-repository">Remote repository</h2>
<h3 id="clone-repository">clone repository</h3>
<p><code>git clone https://github.com/libgit2/libgit2 mylibgit</code> - create folder mylibgit and subfolder .git download all data for this repository and create (checks out) work copy last version. "clone", not "checkout" забирается (pulled) каждая версия каждого файла из истории проекта вы можете потерять часть серверных перехватчиков (server-side hooks) и т.п., но не все данные
<code>git push origin master</code></p>
<h2 id="write-changes-in-repository">write changes in repository</h2>
<p><img alt="write changes in repository" src="img/lifecycle.png" /></p>
<p>pic 7: write changes in repository</p>
<p>только взяли их из хранилища (checked them out)</p>
<h3 id="check-status">check status</h3>
<p><code>git status</code></p>
<h3 id="track-files">track files</h3>
<p><code>git add -a</code></p>
<h3 id="index-change-files">index change files</h3>
<p><code>git add -a</code> -  Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния.
Если вы изменили файл после выполнения git add, вам придётся снова выполнить git add, чтобы проиндексировать последнюю версию файла:</p>
<h3 id="short-out-status">short out status</h3>
<p><code>git status -s</code> or --short
Новые, неотслеживаемые файлы помечены ?? слева от них, файлы добавленные в отслеживаемые помечены A, отредактированные файлы помечены M и так далее. В выводе содержится два столбца - в левом указывается статус файла, а в правой модифицирован ли он после этого. К примеру в нашем выводе, файл README модифицирован в рабочей директории и не проиндексирован, файл lib/simplegit.rb модифицирован и проиндексирован. Файл Rakefile модифицирован, проиндексирован и ещё раз модифицирован, таким образом на данный момент у него есть изменения которые попадут в коммит и те которые не попадут.</p>
<h3 id="ignore-files-gitignore">ignore files .gitignore</h3>
<p>sample</p>
<p><code>*.[oa]
*~</code>
<strong>К шаблонам в файле .gitignore применяются следующие правила:</strong></p>
<ul>
<li>Пустые строки, а также строки, начинающиеся с #, игнорируются.</li>
<li>Можно использовать стандартные glob шаблоны.</li>
<li>Можно начать шаблон символом слэша (/) чтобы избежать рекурсии.</li>
<li>Можно заканчивать шаблон символом слэша (/) для указания каталога.</li>
<li>Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.</li>
</ul>
<p>Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. Символ (<em>) соответствует 0 или более символам; последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (?) соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом ([0-9]), соответствуют любому символу из интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы указать на вложенные директории: a/</em>*/z соответствует a/z, a/b/z, a/b/c/z, и так далее.</p>
<p>```</p>
<h1 id="no-a-files">no .a files</h1>
<p>*.a</p>
<h1 id="but-do-track-liba-even-though-youre-ignoring-a-files-above">but do track lib.a, even though you're ignoring .a files above</h1>
<p>!lib.a</p>
<h1 id="only-ignore-the-root-todo-file-not-subdirtodo">only ignore the root TODO file, not subdir/TODO</h1>
<p>/TODO</p>
<h1 id="ignore-all-files-in-the-build-directory">ignore all files in the build/ directory</h1>
<p>build/</p>
<h1 id="ignore-docnotestxt-but-not-docserverarchtxt">ignore doc/notes.txt, but not doc/server/arch.txt</h1>
<p>doc/*.txt</p>
<h1 id="ignore-all-txt-files-in-the-doc-directory">ignore all .txt files in the doc/ directory</h1>
<p>doc/*<em>/</em>.txt
```</p>
<p><a href="https://github.com/github/gitignore">.gitignore template on github</a></p>
<h3 id="view-index-and-not-index-changes">view index and not index changes</h3>
<p><code>git diff</code> - что вы изменили, но ещё не проиндексировали, и <code>git diff --staged</code> что вы проиндексировали и собираетесь фиксировать (--staged и --cached синонимы). показывает вам непосредственно добавленные и удалённые строки — собственно заплатку (patch).
Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите git diff без аргументов:Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.
Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить <code>git diff --staged</code> or <code>--cached</code>. Эта команда сравнивает ваши индексированные изменения с последним коммитом:</p>
<p><code>git difftool --tool-help</code> - просмотр внешних утилит сравнения таких программ как Araxis, emerge, vimdiff</p>
<h3 id="commit-changes">commit changes</h3>
<p><code>git commit -v</code> Запомните, что коммит сохраняет снимок состояния вашего индекса. Всё, что вы не проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё один коммит</p>
<h3 id="index-ignore">index ignore</h3>
<p><code>git commit -a</code> - заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add:</p>
<h3 id="remove-files">remove files</h3>
<p><code>git rm</code> - удаляет из индекса, также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите его как “неотслеживаемый”. Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции <code>Changes not staged for commit</code> (измененные, но не проиндексированные) Затем, если вы выполните команду git rm, удаление файла попадёт в индекс:
После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра -f. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.
Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть оставить файл на жёстком диске, и убрать его из-под бдительного ока Git. Это особенно полезно, если вы забыли добавить что-то в файл .gitignore и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию --cached:</p>
<p><code>git rm --cached README</code>
В команду git rm можно передавать файлы, каталоги или glob-шаблоны. Это означает, что вы можете вытворять что-то вроде:</p>
<p><code>git rm log/\*.log</code>
Обратите внимание на обратный слэш () перед *. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора. Эта команда удаляет все файлы имеющие расширение .log находящиеся в директории log/. Или же вы можете сделать вот так:</p>
<p><code>git rm \*~</code> Эта команда удаляет все файлы, чьи имена заканчиваются на ~.</p>
<h3 id="move-files">move files</h3>
<p><code>git mv file_from file_to</code> - rename file
Однако, это эквивалентно выполнению следующих команд:</p>
<p><code>mv README.md README
git rm README.md
git add README</code></p>
<p>Единственное отличие состоит лишь в том, что mv — это одна команда вместо трёх — это функция для удобства</p>
<h2 id="history-commit">history commit</h2>
<h3 id="view-history">view history</h3>
<p><code>git log -p -2</code> - list commit for code review</p>
<p><code>git log --stat</code> - short stat for every commit</p>
<p><code>git log --pretty=oneline</code> - every commit in one line</p>
<blockquote>
<p>short, full and fuller</p>
</blockquote>
<p>command log option --pretty</p>
<p><code>git log --pretty=format:"%h - %an, %ar : %s"</code></p>
<p>Table 1. Полезные опции для git log --pretty=format</p>
<table>
<thead>
<tr>
<th>option</th>
<th>disription out</th>
</tr>
</thead>
<tbody>
<tr>
<td>%H</td>
<td>Хеш коммита</td>
</tr>
<tr>
<td>%h</td>
<td>Сокращенный хеш коммита</td>
</tr>
<tr>
<td>%T</td>
<td>Хеш дерева</td>
</tr>
<tr>
<td>%t</td>
<td>Сокращенный хеш дерева</td>
</tr>
<tr>
<td>%P</td>
<td>Хеш родителей</td>
</tr>
<tr>
<td>%p</td>
<td>Сокращенный хеш родителей</td>
</tr>
<tr>
<td>%an</td>
<td>Имя автора</td>
</tr>
<tr>
<td>%ae</td>
<td>Электронная почта автора</td>
</tr>
<tr>
<td>%ad</td>
<td>Дата автора (формат даты можно задать опцией --date=option)</td>
</tr>
<tr>
<td>%ar</td>
<td>Относительная дата автора</td>
</tr>
<tr>
<td>%cn</td>
<td>Имя коммитера</td>
</tr>
<tr>
<td>%ce</td>
<td>Электронная почта коммитера</td>
</tr>
<tr>
<td>%cd</td>
<td>Дата коммитера</td>
</tr>
<tr>
<td>%cr</td>
<td>Относительная дата коммитера</td>
</tr>
<tr>
<td>%s</td>
<td>Содержание</td>
</tr>
</tbody>
</table>
<p>Автор – это человек, изначально сделавший работу, а коммитер – это человек, который последним применил эту работу. Другими словами, если вы создадите патч для какого-то проекта, а один из основных членов команды этого проекта применит этот патч, вы оба получите статус участника – вы как автор и основной член команды как коммитер.</p>
<p><code>git log --pretty=format:"%h %s" --graph</code> - показывает текущую ветку и историю слияний</p>
<p>Table 2. Наиболее распространенные опции для команды git log</p>
<table>
<thead>
<tr>
<th>option</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>Показывает патч для каждого коммита.</td>
</tr>
<tr>
<td>--stat</td>
<td>Показывает статистику измененных файлов для каждого коммита.</td>
</tr>
<tr>
<td>--shortstat</td>
<td>Отображает только строку с количеством изменений/вставок/удалений для команды --stat.</td>
</tr>
<tr>
<td>--name-only</td>
<td>Показывает список измененных файлов после информации о коммите.</td>
</tr>
<tr>
<td>--name-status</td>
<td>Показывает список файлов, которые добавлены/изменены/удалены.</td>
</tr>
<tr>
<td>--abbrev-commit</td>
<td>Показывает только несколько символов SHA-1 чек-суммы вместо всех 40.</td>
</tr>
<tr>
<td>--relative-date</td>
<td>Отображает дату в относительном формате (например, "2 weeks ago") вместо стандартного формата даты.</td>
</tr>
<tr>
<td>--graph</td>
<td>Отображает ASCII граф с ветвлениями и историей слияний.</td>
</tr>
<tr>
<td>--pretty</td>
<td>Показывает коммиты в альтернативном формате. Возможные варианты опций: oneline, short, full, fuller и format (с помощью последней опции вы можете указать свой формат).</td>
</tr>
</tbody>
</table>
<h3 id="limitation-out-filters">Limitation out (filters)</h3>
<p><code>git log --since=2.weeks</code> - покажет список коммитов, сделанных за последние две недели. Это команда работает с большим количеством форматов – вы можете указать определенную дату вида "2008-01-15" или же относительную дату, например "2 years 1 day 3 minutes ago" Также вы можете фильтровать список коммитов, которые удовлетворяют каким-то критериям. Опция --author дает возможность фильтровать по автору коммита, а опция --grep искать по ключевым словам в сообщении коммита. (Имейте ввиду, что если вы хотите фильтровать коммиты по автору и ключевым словам одновременно, вам нужно также добавить --all-match. В противном случае, команда отфильтрует вывод по одному из двух критериев.)</p>
<p><code>git log -Sfunction_name</code> - принимает строку и показывает только те коммиты, в которых изменение в коде повлекло за собой добавление или удаление этой строки. Например, если вы хотите найти последний коммит, который добавил или удалил вызов определенной функции, вы можете запустить команду</p>
<p>Последней полезной опцией, которую принимает команда git log как фильтр, является путь. Если вы укажете директорию или имя файла, вы ограничите вывод только теми коммитами, в которых были изменения этих файлов. Эта опция всегда указывается последней после двойного тире (--), что отделяет указываемый путь от опций.</p>
<p><em>Table 3. Опции для ограничения вывода команды git log</em></p>
<table>
<thead>
<tr>
<th>option</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-(n)</td>
<td>Показывает только последние n коммитов.</td>
</tr>
<tr>
<td>--since, --after</td>
<td>Показывает только те коммиты, которые были сделаны после указанной даты.</td>
</tr>
<tr>
<td>--until, --before</td>
<td>Показывает только те коммиты, которые были сделаны до указанной даты.</td>
</tr>
<tr>
<td>--author</td>
<td>Показывает только те коммиты, в которых запись author совпадает с указанной строкой.</td>
</tr>
<tr>
<td>--committer</td>
<td>Показывает только те коммиты, в которых запись committer совпадает с указанной строкой.</td>
</tr>
<tr>
<td>--grep</td>
<td>Показывает только коммиты, сообщение которых содержит указанную строку.</td>
</tr>
<tr>
<td>-S</td>
<td>Показывает только коммиты, в которых изменение в коде повлекло за собой добавление или удаление указанной строки.</td>
</tr>
</tbody>
</table>
<p>Например, если вы хотите увидеть, в каких коммитах произошли изменения в тестовых файлах в истории исходного кода Git, автором которых был Junio Hamano и которые не были слияниями в октябре 2008 года, вы можете запустить следующую команду:</p>
<p><code>git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \
--before="2008-11-01" --no-merges -- t/</code></p>
<p>Из почти 40,000 коммитов в истории исходного кода Git, эта команда показывает только 6, которые соответствуют этим критериям.</p>
<h2 id="undo-operation">Undo operation</h2>
<p>Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит, можно запустить commit с параметром --amend (дополнить):</p>
<p><code>git commit --amend</code></p>
<p>Например, если вы фиксируете изменения, и понимаете, что забыли проиндексировать изменения в файле, который хотели включить в коммит, можно сделать примерно так:</p>
<p><code>$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend</code></p>
<h3 id="undo-prepare-file">undo prepare file</h3>
<p>области подготовки (staging area) и рабочего каталог.</p>
<p>Например, скажем, вы изменили два файла, и хотите закоммитить их двумя раздельными изменениями, но случайно набрали git add *, и добавили оба в индекс.</p>
<p><code>git reset HEAD CONTRIBUTING.md</code> - отменим индексирование файла CONTRIBUTING.md</p>
<blockquote>
<p>Хотя git reset может стать опасной командой, если ее вызвать с --hard, в приведенном примере файл в вашем рабочем каталоге не затрагивается. Вызов git reset без параметра не опасен — он затрагивает только область подготовки.</p>
</blockquote>
<h3 id="undo-changes-changed-file">undo changes changed file</h3>
<p>Что делать, если вы поняли, что не хотите сохранять свои изменения файла CONTRIBUTING.md? Как можно просто «разызменить» его — вернуть к тому виду, который был в последнем коммите</p>
<p><code>git checkout -- CONTRIBUTING.md</code></p>
<blockquote>
<p>Важно понимать, что git checkout -- [file] — опасная команда. Любые изменения соответствующего файла пропадают — вы просто копируете поверх него другой файл. Ни в коем случае не используйте эту команду, если вы не убеждены, что файл вам не нужен.</p>
</blockquote>
<p>Если вы хотите сохранить изменения файла, но пока отложить их в сторону, давайте пройдемся по тому, как прятать (stash) и создавать ветки (branch) в Ветвление в Git; эти способы обычно лучше.</p>
<p>Помните, все, что зафиксировано коммитом в Git, почти всегда можно восстановить. Можно восстановить даже коммиты, сделанные в удаленных ветках, или коммиты, замещенные параметром --amend (см. Восстановление данных). Но все, что вы потеряете, не сделав коммит, скорее всего, вам больше не увидеть.</p>
<h2 id="work-with-remote-repositorie">Work with remote repositorie</h2>
<p>Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. </p>
<h3 id="view-remote-repo">view remote repo</h3>
<p><code>$ git clone https://github.com/schacon/ticgit
$ cd ticgit
$ git remote</code></p>
<p><code>git remote -v</code> - detailed view address for read and write</p>
<h3 id="add-remote-repo">add remote repo</h3>
<p><code>git remote add pb https://github.com/paulboone/ticgit</code></p>
<p>если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду : <code>git fetch pb</code> Ветка master из репозитория Пола сейчас доступна вам под именем pb/master. Вы можете слить её с одной из ваших веток или переключить на неё локальную ветку, чтобы просмотреть содержимое ветки Пола</p>
<h3 id="get-changes-from-remote-repo">get changes from remote repo</h3>
<p><code>git fetch [remote-name]</code></p>
<p>Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем “origin”. Таким образом, <em>git fetch origin</em> извлекает все наработки, отправленные (push) на этот сервер после того, как вы склонировали его (или получили изменения с помощью fetch). Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.</p>
<p>Если у вас есть ветка, настроенная на отслеживание удалённой ветки то, Выполнение <em>git pull</em>, как правило, извлекает (fetch) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.</p>
<h3 id="send-changes-to-remote-repo">send changes to remote repo</h3>
<p>Когда вы хотите поделиться своими наработками, вам необходимо отправить (push) их в главный репозиторий. <em>git push [remote-name] [branch-name]</em></p>
<p><code>git push origin master</code> - Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Иначе Вам придётся сначала вытянуть (pull) их изменения и объединить с вашими. Только после этого вам будет позволено выполнить push.</p>
<h3 id="view-remote-repo_1">View remote repo</h3>
<p><code>git remote show origin</code> - Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках.</p>
<p><code>$ git remote show origin
* remote origin
  URL: https://github.com/my-org/complex-project
  Fetch URL: https://github.com/my-org/complex-project
  Push  URL: https://github.com/my-org/complex-project
  HEAD branch: master
  Remote branches:
    master                           tracked
    dev-branch                       tracked
    markdown-strip                   tracked
    issue-43                         new (next fetch will store in remotes/origin)
    issue-45                         new (next fetch will store in remotes/origin)
    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)
  Local branches configured for 'git pull':
    dev-branch merges with remote dev-branch
    master     merges with remote master
  Local refs configured for 'git push':
    dev-branch                     pushes to dev-branch                     (up to date)
    markdown-strip                 pushes to markdown-strip                 (up to date)
    master                         pushes to master                         (up to date)</code></p>
<p>Данная команда показывает какая именно локальная ветка будет отправлена на удалённый сервер по умолчанию при выполнении git push. Она также показывает, каких веток с удалённого сервера у вас ещё нет, какие ветки всё ещё есть у вас, но уже удалены на сервере. И для нескольких веток показано, какие удалённые ветки будут в них влиты при выполнении git pull.</p>
<h3 id="remove-and-rename-remote-repo">remove and rename remote repo</h3>
<p><code>git remote rename pb paul</code> - это также меняет для вас имена удалённых веток. То, к чему вы обращались как pb/master, теперь стало paul/master.</p>
<p><code>git remote rm paul</code> - удалить ссылку</p>
<h2 id="work-with-tag">work with tag</h2>
<p>возможность помечать (tag) определённые моменты в истории как важные. Как правило, эта функциональность используется для отметки моментов выпуска версий (v1.0, и т.п.)</p>
<h3 id="view-tags">view tags</h3>
<p><code>git tag</code> - Данная команда перечисляет метки в алфавитном порядке</p>
<p>Для меток вы также можете осуществлять поиск по шаблону. Например, репозиторий Git’а содержит более 500 меток. Если вас интересует просмотр только выпусков 1.8.5, вы можете выполнить следующее:
<code>git tag -l 'v1.8.5*'</code></p>
<h3 id="create-tag">create tag</h3>
<p>Git использует два основных типа меток: легковесные и аннотированные.
Легковесная метка — это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит. В сущности, это контрольная сумма коммита, сохранённая в файл Для создания легковесной метки не передавайте опций -a, -s и -m</p>
<p>А вот аннотированные метки хранятся в базе данных Git’а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG). Обычно рекомендуется создавать аннотированные метки, чтобы иметь всю перечисленную информацию; но если вы хотите сделать временную метку или по какой-то причине не хотите сохранять остальную информацию, то для этого годятся и легковесные метки.</p>
<p><code>git tag -a v1.4 -m 'my version 1.4'</code> - Создание аннотированной метки Опция -m задаёт сообщение метки, которое будет храниться вместе с меткой</p>
<p>Вы можете посмотреть данные метки вместе с коммитом, который был помечен, с помощью команды git show: <code>git show v1.4</code></p>
<p><code>git tag v1.4-lw</code> - На этот раз при выполнении git show на этой метке вы не увидите дополнительной информации. Команда просто покажет помеченный коммит: <code>git show v1.4-lw</code></p>
<h3 id="tagging-later">Tagging later</h3>
<p>Также возможно помечать уже пройденные коммиты. Предположим, что история коммитов выглядит следующим образом:</p>
<p><code>$ git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</code></p>
<p>Теперь предположим, что вы забыли отметить версию проекта v1.2, которая была там, где находится коммит “updated rakefile”. Вы можете добавить метку и позже. Для отметки коммита укажите его контрольную сумму (или её часть) в конце команды:
<code>git tag -a v1.2 9fceb02</code></p>
<h3 id="label-exchange">Label Exchange</h3>
<p>По умолчанию, команда git push не отправляет метки на удалённые серверы. Необходимо явно отправить (push) метки на общий сервер после того, как вы их создали. Это делается так же, как и добавление в репозиторий для совместного использования удалённых веток — нужно выполнить git push origin [имя метки].</p>
<p><code>git push origin v1.5</code></p>
<p>Если у вас есть много меток, которые хотелось бы отправить все за один раз, можно использовать опцию --tags для команды git push. В таком случае все ваши метки отправятся на удалённый сервер (если только их уже там нет).</p>
<p><code>git push origin --tags</code></p>
<h3 id="move-to-a-label">Move to a label</h3>
<p>В действительности вы не можете переходить на метки в Git, поскольку они не могут быть перемещены. Если вы хотите установить версию вашего репозитория в рабочую директорию, которая выглядит, как определенная метка, вы можете создать новую ветку с определенной меткой:
<code>git checkout -b version2 v2.0.0</code></p>
<blockquote>
<p>Конечно, если вы так делаете и коммитите, ваша ветка version2 будет немного отличаться от вашей метки v2.0.0, поскольку она будет двигаться вперед с новыми изменениями, так что будьте осторожны.</p>
</blockquote>
<h2 id="aliases">Aliases</h2>
<p>Если вы не хотите печатать каждую команду для Git’а целиком, вы легко можете настроить псевдонимы (alias) для любой команды с помощью git config. Вот несколько примеров псевдонимов, которые вы, возможно, захотите задать:
<code>git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status</code></p>
<p>Это означает, что, например, вместо ввода git commit, вам достаточно набрать только git ci. </p>
<p>Например, чтобы исправить неудобство, с которым мы столкнулись при исключении файла из индекса, можно добавить в Git свой собственный псевдоним unstage:
<code>git config --global alias.unstage 'reset HEAD --'</code></p>
<p>Это делает эквивалентными следующие две команды:
<code>git unstage fileA
git reset HEAD -- fileA</code></p>
<p>Такой вариант кажется немного более понятным. Также, обычно, добавляют команду last следующим образом:
<code>git config --global alias.last 'log -1 HEAD'</code></p>
<p>Таким образом, можно легко просмотреть последний коммит:</p>
<p>```
git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#100;&#114;&#101;&#97;&#109;&#101;&#114;&#51;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#100;&#114;&#101;&#97;&#109;&#101;&#114;&#51;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a>
Date:   Tue Aug 26 19:48:51 2008 +0800</p>
<pre><code>test for current head

Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;
</code></pre>
<p>```</p>
<p>Однако, возможно, вы захотите выполнить внешнюю команду, а не подкоманду Git’а. В этом случае, следует начать команду с символа !. Это полезно, если вы пишете свои утилиты для работы с Git-репозиторием. Продемонстрируем этот случай на примере создания псевдонима git visual для запуска gitk:
<code>git config --global alias.visual "!gitk"</code></p>
<p>все базовые локальные операции с Git’ом: создавать или клонировать репозиторий, вносить изменения, индексировать и фиксировать эти изменения, а также просматривать историю всех изменений в репозитории</p>
<h2 id="3-branching">3 Branching</h2>
<p>Когда вы делаете коммит, Git сохраняет его в виде объекта, который содержит указатель на снимок (snapshot) подготовленных данных. Этот объект так же содержит имя автора и email, сообщение и указатель на коммит или коммиты непосредственно предшествующие данному (его родителей): отсутствие родителя для первоначального коммита, один родитель для обычного коммита, и несколько родителей для результатов слияния веток.</p>
<p>Представьте себе каталог, который содержит дерево файлов, и вы подготавливаете их все вместе, а затем сохраняете в виде одного коммита. В процессе подготовки вычисляется контрольная сумма каждого файла (SHA-1 как мы узнали из Введение), хранящая версию файла в репозитории Git (Git ссылается на них), затем эти контрольные суммы добавляются в область подготовленных файлов:</p>
<p><code>git add README test.rb LICENSE
git commit -m 'initial commit of my project'</code></p>
<p>Когда вы создаете коммит командой git commit, Git вычисляет контрольные суммы каждого подкаталога (в нашем случае, только основной каталог проекта) и сохраняет эти объекты дерева в репозитории. Затем Git создает объект коммита с метаданными и указателем на основное дерево проекта для возможности воссоздать этот снимок (snapshot) в случае необходимости.</p>
<p><img alt="commit tree" src="img/commit-and-tree.png" /></p>
<p>pic 9: Коммит и его дерево</p>
<p>Если вы сделаете изменения и еще один коммит, тогда следующий коммит сохранит указатель на коммит, предшествующий ему.</p>
<p><img alt="commit parents" src="img/commits-and-parents.png" /></p>
<p>pic 10: Коммит и его родители</p>
<p>Ветка (branch) в Git — это легко перемещаемый указатель на один из этих коммитов. Имя основной ветки по умолчанию в Git — master.</p>
<p>Когда вы делаете коммиты, то получаете основную ветку, указывающую на ваш последний коммит. Каждый коммит автоматически двигает этот указатель вперед.</p>
<p><img alt="branch history" src="img/branch-and-history.png" /></p>
<p>pic 11: Ветка и история коммитов</p>
<h3 id="create-new-branch">create new branch</h3>
<p>Что же на самом деле происходит, когда вы создаете ветку? Всего лишь создается новый указатель для дальнейшего перемещения.</p>
<p><code>git branch testing</code> - В результате создается новый указатель на тот же самый коммит, в котором вы находитесь.</p>
<p><img alt="two branch" src="img/two-branches.png" /></p>
<p>pic 12: Две ветки указывают на одну и ту же последовательность коммитов</p>
<p>Как Git определяет, в какой ветке вы находитесь? Он хранит специальный указатель HEAD. Имейте ввиду, что в Git концепция HEAD значительно отличается от других систем контроля версий, которые вы могли использовать раньше (Subversion или CVS). В Git это указатель на локальную ветку, в которой вы находитесь. В нашем случае мы все еще находимся в ветке “master”. Команда git branch только создает новую ветку. Переключения не происходит.</p>
<p><img alt="head to master" src="img/head-to-master.png" /></p>
<p>pic 13: HEAD указывает на ветку</p>
<p>Вы можете легко это увидеть при помощи простой команды git log. Она покажет вам, куда указывают указатели веток. Эта опция называется --decorate.</p>
<p><code>$ git log --oneline --decorate
f30ab (HEAD, master, testing) add feature #32 - ability to add new
34ac2 fixed bug #1328 - stack overflow under certain conditions
98ca9 initial commit of my project</code></p>
<p>Видны ветки “master” и “testing”, которые указывают на коммит f30ab.</p>
<h3 id="checkout-branch">checkout branch</h3>
<p><code>git checkout testing</code> - В результате указатель HEAD переместится на ветку testing.</p>
<p><img alt="head to new branch" src="img/head-to-testing.png" /></p>
<p>pic 14: HEAD указывает на текущую ветку</p>
<p><code>git commit -a -m 'made a change'</code></p>
<p><img alt="advance branch" src="img/advance-testing.png" /></p>
<p>pic 15: Указатель на ветку HEAD переместился вперед после коммита</p>
<p>Давайте переключимся назад на ветку “master”: <code>git checkout master</code></p>
<p><img alt="back checkout" src="img/checkout-master.png" /></p>
<p>pic 16: HEAD перемещается когда вы делаете checkout</p>
<p>Эта команда сделала две вещи. Она переместила указатель HEAD назад на ветку “master” и вернула файлы в рабочем каталоге в то состояние, которое было сохранено в снимке (snapshot), на который указывает ветка. Это также означает, что все изменения, вносимые с этого момента, будут отнесены к старой версии проекта. Другими словами, откатилась вся работа, выполненная в ветке “testing”, а вы можете продолжать в другом направлении.</p>
<blockquote>
<p>Переключение веток меняет файлы в рабочем каталоге
Важно запомнить, что когда вы переключаете ветки в Git, файлы в рабочем каталоге меняются. Если вы переключаетесь на старую ветку, то рабочий каталог будет выглядеть так же, как выглядел на момент последнего коммита в ту ветку. Если Git по каким-то причинам не может этого сделать — он не позволит вам переключиться.</p>
</blockquote>
<p><code>git commit -a -m 'made other changes'</code></p>
<p>Теперь история вашего проекта разделилась (см Разветвленная история). Вы создали ветку, переключились в нее, поработали, а затем вернулись в основную ветку и поработали в ней. Эти изменения изолированы друг от друга: вы можете свободно переключаться туда и обратно, а когда будете готовы — слить их вместе. И все это делается простыми командами: branch, checkout и commit.</p>
<p><img alt="advanced master branch" src="img/advance-master.png" /></p>
<p>pic 17: Разветвленная история</p>
<p>Все это вы можете увидеть при помощи команды git log. Команда <code>git log --oneline --decorate --graph --all</code> выдаст историю ваших коммитов и покажет, где находятся указатели ваших веток, и как ветвилась история проекта.</p>
<p>Cоздание и удаление веток совершенно не затратно, так как ветка в Git — это всего лишь файл, содержащий 40 символов контрольной суммы SHA-1 того коммита, на который он указывает. Создание новой ветки совершенно быстро и просто — это всего лишь запись 41 байта в файл (40 знаков и перевод строки).</p>
<p>Это совершенно отличает Git от ветвления в большинстве более старых систем контроля версий, где все файлы проекта копируются в другой подкаталог. Там ветвление для проектов разного размера может занять от секунд до минут. В Git ветвление всегда мгновенное. Также, поскольку при коммите мы сохраняем указатель на родительский коммит, найти подходящую базу для слияния в основном очень просто, и это делается для нас автоматически</p>
<p><img alt="work git branches" src="img/work-git-branches.gif" /></p>
<p>pic: work git branches</p>
<h3 id="branch-and-merge">branch and merge</h3>
<p>Давайте рассмотрим простой пример рабочего процесса, который может быть полезен в вашем проекте. Ваша работа построена так:
1. Вы работаете над сайтом.
2. Вы создаете ветку для новой статьи, которую вы пишете.
3. Вы работаете в этой ветке.
В этот момент вы получаете сообщение, что обнаружена критическая ошибка, требующая скорейшего исправления. Ваши действия:
1. Переключиться на основную ветку.
2. Создать ветку для добавления исправления.
3. После тестирования слить ветку содержащую исправление с основной веткой.
4. Переключиться назад в ту ветку где вы пишите статью и продолжить работать.</p>
<h3 id="branching">branching</h3>
<p><img alt="branching 1" src="img/basic-branching-1.png" /></p>
<p>pic 18: Простая история коммитов</p>
<p>Вы решаете, что теперь вы будете заниматься проблемой #53 из вашей системы отслеживания ошибок. Чтобы создать ветку и сразу переключиться на нее, можно выполнить команду git checkout с параметром -b: <code>git checkout -b iss53</code></p>
<p>Это тоже самое что и:</p>
<p><code>git branch iss53
git checkout iss53</code></p>
<p><img alt="branching 2" src="img/basic-branching-2.png" /></p>
<p>pic 19: Создание нового указателя ветки</p>
<p>Вы работаете над своим сайтом и делаете коммиты. Это приводит к тому, что ветка iss53 движется вперед, так как вы переключились на нее ранее (HEAD указывает на нее).
<code>git commit -a -m 'added a new footer [issue 53]'</code></p>
<p><img alt="branching 3" src="img/basic-branching-3.png" /></p>
<p>pic 20: Ветка iss53 двигается вперед</p>
<p>Тут вы получаете сообщение об обнаружении уязвимости на вашем сайте, которую нужно немедленно устранить. Благодаря Git, не требуется размещать это исправление вместе с тем, что вы сделали в iss53. Вам даже не придется прилагать усилий, чтобы откатить все эти изменения для начала работы над исправлением. Все, что вам нужно — переключиться на ветку master.
Но перед тем как сделать это — имейте в виду, что если ваш рабочий каталог либо область подготовленных файлов содержат изменения, не попавшие в коммит и конфликтующие с веткой, на которую вы хотите переключиться, то Git не позволит вам переключить ветки. Лучше всего переключаться из чистого рабочего состояния проекта. Есть способы обойти это (спрятать (stash) или исправить (amend) коммиты), но об этом мы поговорим позже в главе Прибережение и очистка. Теперь предположим, что вы зафиксировали все свои изменения и можете переключиться на основную ветку: <code>git checkout master</code></p>
<blockquote>
<p>Важно запомнить: когда вы переключаете ветки, Git возвращает состояние рабочего каталога к тому виду, какой он имел в момент последнего коммита в эту ветку. Он добавляет, удаляет и изменяет файлы автоматически, чтобы состояние рабочего каталога соответствовало тому, когда был сделан последний коммит.</p>
</blockquote>
<p>Теперь вы можете перейти к написанию исправления. Давайте создадим новую ветку для исправления, в которой будем работать, пока не закончим исправление.</p>
<p><code>$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)</code></p>
<p><img alt="branching 4" src="img/basic-branching-4.png" /></p>
<p>pic 21: Ветка hotfix основана на ветке master </p>
<p>Вы можете прогнать тесты, чтобы убедиться, что ваше исправление делает именно то, что нужно. И если это так — выполнить слияние (merge) с основной веткой для включения в продукт. Это делается командой git merge:</p>
<p><code>$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)</code></p>
<p>Заметили фразу “fast-forward” в этом слиянии? Из-за того, что коммит, на который указывала ветка, которую вы слили, был прямым потомком того коммита, на котором вы находились, Git просто переместил указатель ветки вперед. Другими словами, если коммит сливается с тем, до которого можно добраться, двигаясь по истории прямо, Git упрощает слияние, просто перенося указатель метки вперед (так как нет разветвления в работе). Это называется <code>fast-forward</code> (перемотка). Теперь ваши изменения — в снимке (snapshot) коммита, на который указывает ветка master, и исправления продукта можно внедрять.</p>
<p><img alt="branching 5" src="img/basic-branching-5.png" /></p>
<p>pic 22: master перемотан до hotfix</p>
<p>После внедрения вашего архиважного исправления вы готовы вернуться к работе над тем, что были вынуждены отложить. Но сначала нужно удалить ветку hotfix, потому что она больше не нужна — ветка master указывает на то же самое место. Для удаления ветки выполните команду git branch с параметром -d: <code>git branch -d hotfix</code></p>
<p>Теперь вы можете переключить ветку и вернуться к работе над своей проблемой #53:</p>
<p><code>$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)</code></p>
<p><img alt="branching 6" src="img/basic-branching-6.png" /></p>
<p>pic 23:  Продолжение работы над iss53 </p>
<p>Стоит обратить внимание на то, что все изменения из ветки hotfix не включены в вашу ветку iss53. Если их нужно включить, вы можете влить ветку master в вашу ветку iss53 командой git merge master, или же вы можете отложить слияние этих изменений до завершения работы, и затем влить ветку iss53 в master.</p>
<h3 id="merging">merging</h3>
<p>Предположим, вы решили, что работа по проблеме #53 закончена, и ее можно влить в ветку master. Для этого нужно выполнить слияние ветки iss53 точно так же, как вы делали это с веткой hotfix ранее. Все что нужно сделать — переключиться на ветку, в которую вы хотите включить изменения, и выполнить команду git merge:</p>
<p><code>$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)</code></p>
<p>Результат этой операции отличается от результата слияния ветки hotfix. В данном случае процесс разработки ответвился в более ранней точке. Так как коммит, на котором мы находимся, не является прямым потомком ветки, с которой мы выполняем слияние, Git придется немного потрудиться. В этом случае Git выполняет простое трехстороннее слияние двух снимков (snapshot) сливаемых веток и общего для двух веток родительского снимка.</p>
<p><img alt="merging 1" src="img/basic-merging-1.png" /></p>
<p>pic 24: Использование трех снимков при слиянии</p>
<p>Вместо того, чтобы просто передвинуть указатель ветки вперед, Git создает новый снимок-результат трехстороннего слияния, а затем автоматически делает коммит. Этот особый коммит называют коммитом слияния, так как у него более одного предка.</p>
<p><img alt="merging 2" src="img/basic-merging-2.png" /></p>
<p>pic 25: Коммит слияния</p>
<p>Стоит отметить, что Git сам определяет наилучшего общего предка, подходящего как база для слияния; это отличает его от более старых инструментов, таких как CVS или Subversion (до версии 1.5), где разработчикам, выполнявшим слияние, приходилось самим находить лучшую базу.</p>
<p>Теперь, когда работа влита, ветка iss53 больше не нужна. Вы можете закрыть вопрос в системе отслеживания ошибок и удалить ветку: <code>git branch -d iss53</code></p>
<h3 id="conflicts-merging">conflicts merging</h3>
<p><code>$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.</code></p>
<p>Git не создал коммит слияния автоматически. Он остановил процесс до тех пор, пока вы не разрешите конфликт. Чтобы в любой момент после появления конфликта увидеть, какие файлы не объединены, вы можете запустить git status: Все, где есть неразрешенные конфликты слияния, перечисляется как неслитое.</p>
<p>Все, где есть неразрешенные конфликты слияния, перечисляется как неслитое. Git добавляет в конфликтующие файлы стандартные пометки разрешения конфликтов, чтобы вы могли вручную открыть их и разрешить конфликты. В вашем файле появился раздел, выглядящий примерно так:</p>
<p>```
 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>iss53:index.html
```</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>В этом разрешении есть немного от каждой части, а строки &lt;&lt;&lt;&lt;&lt;&lt;&lt;, ======= и &gt;&gt;&gt;&gt;&gt;&gt;&gt; совсем убраны. Разрешив каждый конфликт во всех файлах, запустите git add для каждого файла, чтобы отметить конфликт как решенный. Подготовка (staging) файла помечает его для Git как разрешенный конфликт.
Если вы хотите использовать графический инструмент для разрешения конфликтов, можно запустить git mergetool, что откроет соответствующее визуальное средство, которое проведет вас по всем конфликтам: <code>git mergetool</code></p>
<p>После выхода из средства слияния Git спрашивает, успешно ли слияние. Если вы утвердительно ответите скрипту, он подготовит (stage) файл, чтобы отметить его как разрешенный. Теперь можно снова запустить git status, чтобы убедиться, что все конфликты разрешены</p>
<p>Если это вас устраивает, и вы убедились, что все, где были конфликты, подготовлено (staged), можете ввести git commit, чтобы завершить коммит слияния.</p>
<h3 id="manage-branches">manage branches</h3>
<p><code>git branch</code> - вы получите простой список имеющихся у вас веток, а символ *, стоящий перед веткой master: он указывает на ветку, на которой вы находитесь в настоящий момент (т.е. ветку, на которую указывает HEAD). </p>
<p>Чтобы посмотреть последний коммит на каждой из веток, выполните команду <code>git branch -v</code></p>
<p>Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду <code>git branch --merged</code>: Те ветки из этого списка, перед которыми нет символа *, можно смело удалять командой git branch -d; наработки из этих веток уже включены в другую ветку, так что ничего не потеряется.</p>
<p>Чтобы увидеть все ветки, содержащие наработки, которые вы пока ещё не слили в текущую ветку, выполните команду <code>git branch --no-merged</code>: Так как ветка содержит ещё не слитые наработки, попытка удалить её командой git branch -d приведет к ошибке: Если вы действительно хотите удалить ветку и потерять наработки, вы можете сделать это при помощи опции -D</p>
<h3 id="work-with-branch">work with branch</h3>
<h3 id="_1">Долгоживущие ветки</h3>
<p>Так как в Git применяется простое трехэтапное слияние, ничто не мешает многократно объединять ветки в течении длительного времени. То есть у вас может быть несколько постоянно открытых веток, применяемых для разных этапов цикла разработки. Содержимое некоторых из них будет регулярно сливаться в другие ветки.
Многие разработчики, использующие Git, придерживаются именно такого подхода, оставляя полностью стабильный код только в ветке master. При этом существует и параллельная ветка с именем develop или next, служащая для работы и тестирования стабильности. После достижения стабильного результата ее содержимое сливается в ветку master. Она используется для объединения завершенных задач из тематических веток (временных веток наподобие iss53), чтобы гарантировать, что эти задачи проходят тестирование и не вносят ошибок.
По сути, мы рассматриваем указатели, перемещающиеся по линии фиксируемых нами изменений. Стабильные ветки находятся в нижнем конце истории коммитов, а самые свежие наработки — ближе к ее верхней части</p>
<p><img alt="lr 1" src="img/lr-branches-1.png" /></p>
<p>pic 26: Линейное представление повышения стабильности веток</p>
<p>В общем случае можно представить набор рабочих накопителей, в котором наборы коммитов перемещаются на более стабильный уровень только после полного тестирования</p>
<p><img alt="lr 2" src="img/lr-branches-2.png" /></p>
<p>pic 27: Представление диаграммы стабильности веток в виде многоуровневого накопителя</p>
<p>Число уровней стабильности можно увеличить. В крупных проектах зачастую появляется ветка proposed или pu (proposed updates), объединяющая ветки с содержимым, которое невозможно включить в ветку next или master. Фактически каждая ветка представляет собственный уровень стабильности. Как только он повышается, содержимое сливается в ветку, расположенную выше. Разумеется, можно и вообще обойтись без долгоживущих веток, но зачастую они имеют смысл, особенно при работе над большими и сложными проектами.</p>
<h3 id="_2">Тематические ветки</h3>
<p>А вот такая вещь, как тематические ветки, полезна вне зависимости от величины проекта. Тематической (topic branch) называется временная ветка, создаваемая и используемая для работы над конкретной функциональной возможностью или решения сопутствующих задач.</p>
<p>Пример тематических веток вы видели в предыдущем разделе, когда мы создавали ветки iss53 и hotfix. Для каждой из них было выполнено несколько коммитов, после чего сразу же после слияния с основной веткой они были удалены. Такая техника позволяет быстро и радикально осуществлять переключения контекста. Работа разделена по уровням, и все изменения в конкретной ветке относятся к определенной теме, а значит, во время просмотра кода проще понять, что и где было сделано. Ветку с внесенными в нее изменениями можно хранить минуты, дни или даже месяцы, и выполнять ее слияние, только когда это действительно требуется, независимо от порядка создания веток в рамках проекта и порядка работы с ними.
Предположим, мы работаем в ветке master, ответвляемся для решения попутной проблемы (iss91), некоторое время занимаемся ею, затем создаем ветку, чтобы попробовать решить эту задачу другим способом (iss91v2), возвращаемся в ветку master, выполняем там некие действия и создаем новую ветку для действий, в результате которых не уверены (ветка dumbidea). Результирующая история коммитов будет выглядеть примерно так:</p>
<p><img alt="topic 1" src="img/topic-branches-1.png" /></p>
<p>pic 28: Набор тематических веток</p>
<p>Предположим, вам больше нравится второй вариант решения задачи (iss91v2), а ветку dumbidea вы показали коллегам, и оказалось, что там содержится гениальная идея. Фактически вы можете удалить ветку iss91 (потеряв коммиты C5 и C6) и слить две другие ветки. После этого история будет выглядеть так:</p>
<p><img alt="topic 2" src="img/topic-branches-2.png" /></p>
<p>pic 29: История после слияния веток dumbidea и iss91v2</p>
<h3 id="remote-branch">remote branch</h3>
<p>Удалённые ветки — это ссылки (pointers) на состояние веток в ваших удалённых репозиториях. Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети. Удалённые ветки действуют как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.</p>
<p>Они выглядят как (имя удал. репоз.)/(ветка). Например, если вы хотите посмотреть, как выглядела ветка master на сервере origin во время последнего соединения с ним, проверьте ветку origin/master. Если вы с партнёром работали над одной проблемой, и он выложил ветку iss53, у вас может быть своя локальная ветка iss53; но та ветка на сервере будет указывать на коммит в origin/iss53.</p>
<blockquote>
<p>Если вы запустите git clone -o booyah, так вы будете иметь booyah/master как вашу удаленную ветку по умолчанию.</p>
</blockquote>
<p><img alt="remote brances 1" src="img/remote-branches-1.png" />
 pic 30: Серверный и локальный репозитории после клонирования</p>
<p>Если вы сделаете что-то в своей локальной ветке master, а тем временем кто-то ещё отправит (push) изменения на git.ourcompany.com и обновит там ветку master, то ваши истории продолжатся по-разному. Ещё, до тех пор, пока вы не свяжетесь с сервером origin, ваш указатель origin/master не будет сдвигаться.</p>
<p><img alt="remote branches 2" src="img/remote-branches-2.png" /></p>
<p>pic 31: Локальная и удаленная работа может расходиться</p>
<p>Для синхронизации вашей работы выполняется команда git fetch origin. Эта команда ищет, какому серверу соответствует “origin” (в нашем случае это git.ourcompany.com); извлекает оттуда все данные, которых у вас ещё нет, и обновляет ваше локальное хранилище данных; сдвигает указатель origin/master на новую позицию.</p>
<p><img alt="remote branches 3" src="img/remote-branches-3.png" /></p>
<p>pic 32: git fetch обновляет ваши удаленные ссылки</p>
<p>Чтобы продемонстрировать то, как будут выглядеть удалённые ветки в ситуации с несколькими удалёнными серверами, предположим, что у вас есть ещё один внутренний Git-сервер, который используется для разработки только одной из ваших команд разработчиков. Этот сервер находится на git.team1.ourcompany.com. Вы можете добавить его в качестве новой удалённой ссылки на проект, над которым вы сейчас работаете с помощью команды git remote add так же, как было описано в Основы Git. Дайте этому удалённому серверу имя teamone, которое будет сокращением для полного URL.</p>
<p><img alt="remote branches 4" src="img/remote-branches-4.png" /></p>
<p>pic 33: Добавление еще одного сервера в качестве удаленной ветки</p>
<p>Теперь можете выполнить git fetch teamone, чтобы извлечь всё, что есть на сервере и нет у вас. Так как в данный момент на этом сервере есть только часть данных, которые есть на сервере origin, Git не получает никаких данных, но выставляет удалённую ветку с именем teamone/master, которая указывает на тот же коммит, что и ветка master на сервере teamone.</p>
<p><img alt="remote branches 5" src="img/remote-branches-5.png" /></p>
<p>pic 34: Удаленное отслеживание ветки teamone/master</p>
<h3 id="send-changes-to-remote">send changes to remote</h3>
<p>Таким образом, вы можете использовать свои личные ветки для работы, которую вы не хотите показывать, и отправлять только те тематические ветки, над которыми вы хотите работать с кем-то совместно.
Если у вас есть ветка serverfix, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно так же, как вы отправляли вашу первую ветку. Выполните git push (удал. сервер) (ветка): <code>git push origin serverfix</code></p>
<p>Это в некотором роде сокращение. Git автоматически разворачивает имя ветки serverfix до refs/heads/serverfix:refs/heads/serverfix, что означает “возьми мою локальную ветку serverfix и обнови ей удалённую ветку serverfix.” Мы подробно обсудим часть с refs/heads/ в Git изнутри, но обычно её можно опустить. Вы также можете выполнить git push origin serverfix:serverfix — произойдёт то же самое — здесь говорится “возьми мой serverfix и сделай его удалённым serverfix.” Можно использовать этот формат для отправки локальной ветки в удалённую ветку с другим именем. Если вы не хотите, чтобы ветка называлась serverfix на удалённом сервере, то вместо предыдущей команды выполните git push origin serverfix:awesomebranch. Так ваша локальная ветка serverfix отправится в ветку awesomebranch удалённого проекта.</p>
<blockquote>
<p>Если вы не хотите каждый раз вводить ваши данные, когда вы отправляете изменения, вы можете установить “кэш учетных данных”. Проще всего просто держать их в памяти несколько минут, вы можете легко настроить с помощью команды git config --global credential.helper cache.</p>
</blockquote>
<p>В следующий раз, когда один из ваших соавторов будет получать обновления с сервера, он получит ссылку на то, на что указывает serverfix на сервере, как удалённую ветку origin/serverfix: <code>git fetch origin</code></p>
<blockquote>
<p>Важно отметить, что когда при получении данных у вас появляются новые удалённые ветки, вы не получаете автоматически для них локальных редактируемых копий. Другими словами, в нашем случае вы не получите новую ветку serverfix — только указатель origin/serverfix, который вы не можете менять.</p>
</blockquote>
<p>Чтобы слить эти наработки в свою текущую рабочую ветку, выполните git merge origin/serverfix. Если вам нужна своя собственная ветка serverfix, над которой вы сможете работать, то вы можете создать её на основе удалённой ветки: <code>git checkout -b serverfix origin/serverfix</code> Это даст вам локальную ветку, на которой можно работать. Она будет начинаться там, где и origin/serverfix.</p>
<h3 id="branch-tracking">branch tracking</h3>
<p>Получение локальной ветки из удалённой ветки автоматически создаёт то, что называется “отслеживаемой веткой” (или иногда “upstream branch”). Отслеживаемые ветки — это локальные ветки, которые напрямую связаны с удалённой веткой. Если, находясь на отслеживаемой ветке, вы наберёте git pull, Git уже будет знать, с какого сервера получить все удалённые ссылки и сделает слияние с соответствующей удалённой веткой. Аналогично выполнение git pull на одной из таких веток, сначала получает все удалённые ссылки, а затем автоматически делает слияние с соответствующей удалённой веткой.
При клонировании репозитория, как правило, автоматически создаётся ветка master, которая отслеживает origin/master. Однако, вы можете настроить отслеживание и других веток, допустим если вы хотите, чтобы одни ветки отслеживались с другого удаленного репозитория или не хотите отслеживать ветку master. Простой пример, как это сделать, вы увидели только что — git checkout -b [ветка] [удал. сервер]/[ветка]. Существует общепринятая операция, которую git предоставляет, --track: <code>git checkout --track origin/serverfix</code></p>
<p>Чтобы настроить локальную ветку с именем, отличным от имени удалённой ветки, вы можете легко использовать первую версию с другим именем локальной ветки: <code>git checkout -b sf origin/serverfix</code> Теперь ваша локальная ветка sf будет автоматически получать (pull) изменения из origin/serverfix.</p>
<p>Если у вас уже есть локальная ветка и вы хотите настроить ее на удаленную ветку, которую вы только получили, или хотите изменить upstream-ветку, которую вы отслеживаете, вы можете воспользоваться ключами -u или --set-upstream-to с командой git branch, чтобы явно установить ее в любое время. <code>git branch -u origin/serverfix</code></p>
<blockquote>
<p><strong>Сокращение Upstream</strong>
Если у вас есть установленная отслеживаемая ветка, вы можете ссылаться на нее с помощью @{upstream} или @{u} сокращенно. Итак, если вы находитесь на master-ветке, а отслеживается origin/master, вы можете вызвать что-то вроде git merge @{u} вместо git merge origin/master если хотите.</p>
</blockquote>
<p>Если вы хотите посмотреть какие отслеживаемые ветки у вас установлены, вы можете воспользоваться опцией -vv в команде git branch. Отобразится список ваших локальных веток с дополнительной информацией, включая то, какая из веток отслеживается, и если локальная ветка опережает, отстает или равняется относительно основной ветки. <code>git branch -vv</code></p>
<p><code>$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new</code></p>
<p>Итак, здесь мы можем видеть, что наша iss53-ветка отслеживает origin/iss53 и она опережает на два изменения, означающее, что мы имеем два локальных коммита, которые не отправлены на сервер. Мы может также увидеть, что наша master-ветка отслеживает origin/master и она в актуальном состоянии. Далее мы можем видеть, что наша serverfix-ветка отслеживает server-fix-good-ветку на нашем teamone-сервере и опережает на три коммита и отстает на один, означающее, что есть один коммит на сервере, который мы еще не слили и три локальных коммита, которые вы еще не отправили. В конце мы видим, что наша testing-ветка не отслеживает удаленную ветку.
Важно отметить, что эти цифры — только с каждого сервера, которые последний раз были извлечены. Эта команда не обращается к серверам, она говорит вам о том, что в кэше есть локальная информация с серверов. Если вы хотите полностью быть в курсе опережающих и отстающих коммитов, вам необходимо извлечь данные из всех ваших удаленных серверов перед запуском этой команды. Вы можете сделать нечто подобное: $ git fetch --all; git branch -vv</p>
<h3 id="get-changes">get changes</h3>
<p>Команда git fetch загрузит с сервера все изменения, которых у вас еще нет, но пока не будет изменять вашу рабочую директорию. Эта команда просто получает данные для вас и позволяет вам самостоятельно сделать слияние. Тем не менее, существует команда под названием git pull, которая является по существу командой git fetch, непосредственно за которой следует команда git merge, в большинстве случаев. Если у вас есть отслеживаемая ветка как показано в предыдущем разделе, либо она явно установлена или она содержится вследствие создания вами командами clone или checkout, git pull увидит, что сервер и ветка вашей текущей ветки отслеживается, извлечет с сервера и затем попытается объединить в удаленную ветку.</p>
<h3 id="remove-branch-on-remote-server">remove branch on remote server</h3>
<p>Вы можете удалить ветку на удалённом сервере, используя опцию --delete для git push. Если вы хотите удалить ветку serverfix на сервере, выполните следующее: <code>git push origin --delete serverfix</code></p>
<p>В основном всё, что делает эта строка, — удаляет указатель на сервере. Как правило, Git-сервер оставит данные на некоторое время, пока не запустится сборщик мусора. Итак, если ветка случайно была удалена, чаще всего ее легко восстановить.</p>
<h3 id="rebase">rebase</h3>
<h3 id="simple-rebase">simple rebase</h3>
<p><img alt="rebase 1" src="img/basic-rebase-1.png" /></p>
<p>pic 35: История коммитов простого разделения</p>
<p><img alt="rebase 2" src="img/basic-rebase-2.png" /></p>
<p>pic 36: Слияние разделенной истории коммитов</p>
<p>Тем не менее, есть и другой способ: вы можете взять те изменения, что были представлены в C4 и применить их поверх C3. В Git это называется перебазированием (rebasing). С помощью команды rebase вы можете взять все изменения, которые были зафиксированы (commited) в одной ветке и применить их к другой ветке.</p>
<p><code>$ git checkout experiment
$ git rebase master</code></p>
<p>Это работает следующим образом: берется общий родительский снимок (snapshot) двух веток (той, в которой вы находитесь, и той, поверх которой вы выполняете перебазирование); берется дельта (diff) каждого коммита той ветки, на который вы находитесь, эти дельты сохраняются во временные файлы; текущая ветка устанавливается на тот же коммит, что и ветка, поверх которой вы выполняете перебазирование; и, наконец, ранее сохраненные дельты применяются поочереди.</p>
<p><img alt="rebase 3" src="img/basic-rebase-3.png" /></p>
<p>pic 37: Перебазирование изменений из C4 поверх C3</p>
<p>На этом моменте вы можете переключиться обратно на ветку master и выполнить слияние перемоткой.</p>
<p><code>$ git checkout master
$ git merge experiment</code></p>
<p><img alt="rebase 4" src="img/basic-rebase-4.png" /></p>
<p>pic 38: Перемотка ветки master</p>
<p>Теперь снимок (snapshot), на который указывает C4' абсолютно такой же, как тот, на который указывал C5 в примере с трехсторонним слиянием.</p>
<p>Учтите, что снимок, на который ссылается ваш последний коммит — является ли он последним коммитом после перебазирования или коммитом слияния после слияния — в обоих случаях это один и тот же снимок, отличаются только истории коммитов. Перебазирование повторяет изменения из одной ветки поверх другой в порядке, в котором эти изменения были представлены, в то время как слияние берет две конечные точки и сливает их вместе.</p>
<h3 id="advanced-rebase">advanced rebase</h3>
<p>Также возможно сделать так, чтобы при перемещении воспроизведение коммитов начиналось не от той ветки, на которую делается перемещение.</p>
<p><img alt="advanced rebase" src="img/interesting-rebase-1.png" /></p>
<p>pic 39:  История разработки с тематической веткой, ответвлённой от другой тематической ветки</p>
<p>Предположим, вы решили, что хотите внести свои изменения для клиентской части в основную линию разработки для релиза, но при этом хотите оставить в стороне изменения для серверной части до полного тестирования. Вы можете взять изменения из ветки client, которых нет в server (C8 и C9), и применить их на ветке master при помощи опции --onto команды git rebase: <code>git rebase --onto master server client</code></p>
<p>Это прямое указание “переключиться на ветку client, то есть взять изменения от общего предка веток client и server и повторить их на master”.</p>
<p><img alt="advanced rebase" src="img/interesting-rebase-2.png" /></p>
<p>pic 40: Перемещение тематической ветки, ответвлённой от другой тематической ветки</p>
<p>Теперь вы можете выполнить перемотку (fast-forward) для ветки master (см Перемотка ветки master для добавления изменений из ветки client): </p>
<p><code>$ git checkout master
$ git merge client</code></p>
<p><img alt="advanced rebase" src="img/interesting-rebase-3.png" /></p>
<p>pic 41:  Перемотка ветки master для добавления изменений из ветки client</p>
<p>Представим, что вы решили добавить наработки и из ветки server. Вы можете выполнить перемещение ветки server на ветку master без предварительного переключения на эту ветку при помощи команды git rebase [осн. ветка] [тем. ветка], которая делает тематическую ветку (в данном случае server) текущей и применяет её изменения к основной ветке (master): <code>git rebase master server</code></p>
<p>Эта команда поместит результаты работы в ветке server в начало ветки master, как это показано на Rebasing your server branch on top of your master branch.</p>
<p><img alt="advanced rebase" src="img/interesting-rebase-4.png" /></p>
<p>pic 42: Rebasing your server branch on top of your master branch</p>
<p>После чего вы сможете выполнить перемотку основной ветки (master):</p>
<p><code>$ git checkout master
$ git merge server</code></p>
<p>Теперь вы можете удалить ветки client и server, поскольку весь ваш прогресс уже включен [в основную линию разработки], и больше нет нужны сохранять эти ветки. Полную историю вашего рабочего процесса отражает рисунок Окончательная история коммитов:</p>
<p><code>$ git branch -d client
$ git branch -d server</code></p>
<p><img alt="advanced rebase" src="img/interesting-rebase-5.png" /></p>
<p>pic 43: Окончательная история коммитов</p>
<h3 id="_3">Опасности перемещения</h3>
<blockquote>
<p><strong>Не перемещайте коммиты, уже отправленные в публичный репозиторий</strong></p>
</blockquote>
<p>Когда вы что-то перемещаете, вы отменяете существующие коммиты и создаёте новые, похожие на старые, но являющиеся другими. Если вы выкладываете (push) свои коммиты куда-нибудь, и другие забирают (pull) их себе и в дальнейшем основывают на них свою работу, а затем вы переделываете эти коммиты командой git rebase и выкладываете их снова, ваши коллеги будут вынуждены заново выполнять слияние для своих наработок. В итоге, когда вы в очередной раз попытаетесь включить их работу в свою, вы получите путаницу.</p>
<p><img alt="perils-of-rebasing 1" src="img/perils-of-rebasing-1.png" /></p>
<p>pic 44: Клонирование репозитория и выполнение в нем какой-то работы</p>
<p><img alt="perils-of-rebasing 2" src="img/perils-of-rebasing-2.png" /></p>
<p>pic 45: Извлекаем ещё коммиты и сливаем их со своей работой</p>
<p>Далее тот, кто выложил содержащий слияние коммит, решает вернуться и вместо слияния (merge) переместить (rebase) свою работу; он выполняет git push --force, чтобы переписать историю на сервере. Когда вы извлекаете изменения (fetch) с сервера, вы извлекаете эти новые коммиты.</p>
<p><img alt="perils-of-rebasing 3" src="img/perils-of-rebasing-3.png" /></p>
<p>pic 46: Кто-то выложил перемещенные (rebase) коммиты, отменяя коммиты, на которых основывалась ваша работа</p>
<p>Теперь вы оба в неловком положении. Если вы выполните git pull, вы создадите коммит слияния, включающий обе линии истории, и ваш репозиторий будет выглядеть следующим образом:</p>
<p><img alt="perils-of-rebasing 4" src="img/perils-of-rebasing-4.png" /></p>
<p>pic 47: Вы снова выполняете слияние для той же самой работы в новый коммит слияния</p>
<p>Если вы запросите git log, пока ваша история выглядит таким образом, вы увидите два коммита с одинаковыми авторами, датой, и сообщением, что может сбить с толку. Помимо этого, если вы отправите (push) в таком состоянии свою историю на удаленный сервер, вы вернете все эти перемещенные коммиты на центральный сервер, что ещё больше всех запутает. Довольно логично предположить, что разработчик не хочет, чтобы C4 и C6 были в истории, и именно поэтому она перебазируется в первую очередь.</p>
<h3 id="_4">Меняя базу, меняй основание</h3>
<p>Если вы попадаете в ситуацию, подобную этой, у Git есть особая магия на такой случай. Если кто-то в вашей комаде форсирует отправку на сервер (push), изменений, переписывающих работу, на которых базировалась ваша работа; ваша задача будет состоять в том, чтобы определить, что именно было непосредственно ваше, а что было переписано ими.</p>
<p>Получается, что помимо контрольной суммы коммита SHA-1, Git также вычисляет контрольную сумму, основанную на патче, добавленом с коммитом. Это называется “patch-id”.
Если вы скачаете (pull) в свой локальный репозиторий работу, которая была переписана, и замените (rebase) ею новые коммиты вашего партнера, нередко Git может успешно определить, какие именно изменения были внесены именно вами, и вытащить их в начало новой ветки.</p>
<p>К примеру, если бы в предыдущем сценарии вместо слияния в Кто-то выложил перемещенные (rebase) коммиты, отменяя коммиты, на которых основывалась ваша работа мы выполним git rebase teamone/master, Git будет:
<em> Определять, какая работа уникальна для вашей ветки (C2, C3, C4, C6, C7)
</em> Определять, какие коммиты не были коммитами слияния (C2, C3, C4)
<em> Определять, что не было перезаписано в тематическую ветку (только C2 и C3, поскольку C4 - это тот же патч, что и C4')
</em> Применять эти коммиты к началу teamone/master
Таким образом, вместо результата, который мы можем наблюдать на Вы снова выполняете слияние для той же самой работы в новый коммит слияния, у нас получилось бы что-то вроде Перемещение в начало force-pushed перемещенной работы.</p>
<p><img alt="perils-of-rebasing 5" src="img/perils-of-rebasing-5.png" /></p>
<p>pic 48: Перемещение в начало force-pushed перемещенной работы.</p>
<p>Это возможно, если C4 и C4', который был сделан вашим партнером, фактически является точно таким же патчем. В противном случае rebase не сможет сказать, что это дубликат, и создаст ещё один подобный C4 патч (который с большой вероятностью не удастся применить чисто, поскольку в нём уже присутствуют некоторые изменения).
Вы можете это упростить, применив git pull --rebase вместо обычного git pull. Также возможно осуществить это вручную с помощью git fetch, примененного после git rebase teamone/master.
Если вы используете git pull и хотите сделать --rebase по умолчанию, вы можете установить значение конфигурации pull.rebase чем-то вроде этого git config --global pull.rebase true.
Если вы рассматриваете перемещение (rebase) как способ наведения порядка и работы с коммитами до их отправки (push), и если вы только перемещаете те коммиты, которые никогда не будут доступны публично, у вас всё будет хорошо. Однако если вы перемещаете коммиты, которые уже выложены (push) в публичный репозиторий, и есть вероятность, что работы некоторых людей основываются на тех коммитах, то ваши действия могут вызвать существенные проблемы, а вы - вызвать презрение вашей команды.
Если в какой-то момент вы или партнер находите необходимость в этом, убедитесь, что все знают, как применять команду git pull --rebase, чтобы минимизировать ущерб от подобных действий.</p>
<h3 id="vs">Перемещение vs. Слияние</h3>
<p>что означает история.
Одна из точек зрения заключается в том, что история коммитов в вашем репозиториии - это <strong>запись того, что на самом деле произошло</strong>. Это исторический документ, ценный сам по себе, и его нельзя подделывать. С этой точки зрения изменение истории коммитов почти кощунственно, вы <em>лжете</em> о том, что на самом деле произошло. Но что, если произошла путаница в коммитах слияния? Если это случается, репозиторий должен сохранить это для потомков.
Противоположная точка зрения заключается в том, что история коммитов - это <strong>история того, как был сделан ваш проект</strong>. Вы не опубликовали бы первый черновик книги, и руководство о том, как поддерживать ваше программное обеспечение, нуждается в тщательном редактировании. Это платформа, использующая такие инструменты, как rebase и filter-branch, чтобы рассказать историю наилучшим для будущих читателей образом.
Теперь к вопросу о том, что лучше - слияние или перемещение: надеюсь, вы увидели, что это не так просто. Git - мощный инструмент, позволяющий сделать множество вещей и в вашей истории, и с вашей историей, однако каждая команда и каждый проект индивидуален. Теперь, когда вы знаете, как работают оба эти приёма, выбор - какой из них будет лучше в вашей ситуации - решать вам.
В основном, стоит взять лучшее от обоих миров - использовать перемещение (rebase) для локальных изменений, ещё не отправленных на удаленный сервер (push), чтобы навести порядок в вашей истории; но никогда не перемещать (rebase) ничего, что уже было отправлено (push) куда-то.</p>
<p><strong>Итого:</strong> Вы должны быть способны свободно создавать и переключаться на новую ветку, переключаться между ветками и сливать локальные ветки вместе. Также Вы должны уметь выкладывать Ваши ветки на общий сервер, работать с другими людьми над общими ветками и интегрировать Ваши ветки до того, как они будут доступны другим разработчикам.</p>
<h2 id="4-server">4 server</h2>
<p>Удаленный репозиторий — это обычно голый (чистый, bare) репозиторий ― репозиторий Git, не имеющий рабочего каталога. Поскольку этот репозиторий используется только для обмена, то нет причин создавать рабочую копию файлов на диске, и он содержит только данные Git.
Проще говоря, голый репозиторий содержит только каталог .git вашего проекта и ничего больше.</p>
<h3 id="local-prolocol">local prolocol</h3>
<p>для клонирования локального репозитория вы можете выполнить что-то вроде этого:
<code>git clone /opt/git/project.git</code>
Или этого:
<code>git clone file:///opt/git/project.git</code></p>
<p>Git работает немного по-другому, если вы явно укажете префикс file:// в начале вашего URL. Когда вы просто указываете путь, Git пытается использовать жесткие ссылки и копировать файлы, когда это нужно. Если вы указываете file://, Git работает с данными так же, как при использовании сетевых протоколов, что в целом — менее эффективный способ передачи данных. Причиной для использования file:// может быть необходимость создания чистой копии репозитория без лишних внешних ссылок и объектов, обычно после импорта из другой системы управления версиями или чего-то похожего (см. Git изнутри о задачах поддержки). Мы будем использовать обычные пути, поскольку это практически всегда быстрее.
Чтобы добавить локальный репозиторий в существующий проект, вы можете воспользоваться командой:
<code>git remote add local_proj /opt/git/project.git</code></p>
<p>Репозиторий на NFS часто медленнее, чем репозиторий через SSH на том же сервере, позволяющий Git использовать на полную локальные диски на каждой системе.</p>
<h3 id="https">HTTP/s</h3>
<p>Новая версия часто называется “Умным” (“Smart”) HTTP, а старая “Тупым” (“Dumb”) HTTP</p>
<h3 id="ssh">Протокол SSH</h3>
<p>Чтобы клонировать Git-репозиторий по SSH, вы можете указать префикс ssh:// в URL, например:
$ git clone ssh://user@server/project.git
Или можно использовать для протокола SSH краткий синтаксис наподобие scp:
$ git clone user@server:project.git</p>
<h3 id="git-">Git-протокол</h3>
<p>Вместе с Git поставляется специальный демон, который слушает отдельный порт (9418) и предоставляет сервис, схожий с протоколом SSH, но абсолютно без аутентификации. Чтобы использовать Git-протокол для репозитория, вы должны создать файл git-export-daemon-ok</p>
<h2 id="5-git-distributed-workflows">5 Распределенный Git - Distributed Workflows</h2>
<h3 id="centralized-workflow">Centralized Workflow</h3>
<p><img alt="centralized_workflow" src="img/centralized_workflow.png" /></p>
<p>pic 54: Centralized workflow</p>
<h3 id="integration-manager-workflow">Integration-Manager Workflow</h3>
<p>The process works as follows (see Integration-manager workflow.):
1. The project maintainer pushes to their public repository.
2. A contributor clones that repository and makes changes.
3. The contributor pushes to their own public copy.
4. The contributor sends the maintainer an e-mail asking them to pull changes.
5. The maintainer adds the contributor’s repo as a remote and merges locally.
6. The maintainer pushes merged changes to the main repository.</p>
<p><img alt="integration-manager" src="img/integration-manager.png" /></p>
<p>pic 55: Integration-manager workflow.</p>
<p>This is a very common workflow with hub-based tools like GitHub or GitLab, where it’s easy to fork a project and push your changes into your fork for everyone to see. One of the main advantages of this approach is that you can continue to work, and the maintainer of the main repository can pull in your changes at any time. Contributors don’t have to wait for the project to incorporate their changes – each party can work at their own pace.</p>
<h3 id="dictator-and-lieutenants-workflow">Dictator and Lieutenants Workflow</h3>
<p>The process works like this (see Benevolent dictator workflow.):
1. Regular developers work on their topic branch and rebase their work on top of master. The master branch is that of the dictator.
2. Lieutenants merge the developers' topic branches into their master branch.
3. The dictator merges the lieutenants' master branches into the dictator’s master branch.
4. The dictator pushes their master to the reference repository so the other developers can rebase on it.</p>
<p><img alt="benevolent-dictator" src="img/benevolent-dictator.png" /></p>
<p>pic 56: Benevolent dictator workflow.</p>
<p>This kind of workflow isn’t common, but can be useful in very big projects, or in highly hierarchical environments. It allows the project leader (the dictator) to delegate much of the work and collect large subsets of code at multiple points before integrating them.</p>
<h3 id="workflows-summary">Workflows Summary</h3>
<p>These are some commonly used workflows that are possible with a distributed system like Git, but you can see that many variations are possible to suit your particular real-world workflow. Now that you can (hopefully) determine which workflow combination may work for you, we’ll cover some more specific examples of how to accomplish the main roles that make up the different flows. In the next section, you’ll learn about a few common patterns for contributing to a project.</p>
<h3 id="contributing-to-a-project">Contributing to a Project</h3>
<p>First, you don’t want to submit any whitespace errors. Git provides an easy way to check for this – before you commit, run git diff --check, which identifies possible whitespace errors and lists them for you.</p>
<p><a href="https://git-scm.com/book/ru/v2/Распределенный-Git-Contributing-to-a-Project">Contributing to a Project</a></p>
<h3 id="private-small-team">Private Small Team</h3>
<p>Centralized Workflow</p>
<p>John</p>
<p>```</p>
<h1 id="johns-machine">John's Machine</h1>
<p>$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
```</p>
<p>next
<code>$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'</code></p>
<p><code>git fetch origin</code></p>
<p><img alt="small-team-1" src="img/small-team-1.png" /></p>
<p>pic 58: John’s divergent history.</p>
<p><code>git merge origin/master</code></p>
<p><img alt="small-team-2" src="img/small-team-2.png" /></p>
<p>pic 59: John’s repository after merging origin/master.</p>
<p><code>git push origin master</code></p>
<p><img alt="small-team-3" src="img/small-team-3.png" /></p>
<p>pic 60: John’s history after pushing to the origin server.</p>
<p>Jessica</p>
<p>```</p>
<h1 id="jessicas-machine">Jessica's Machine</h1>
<p>$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
```</p>
<p>next
<code>git push origin master</code></p>
<p><img alt="small-team-4" src="img/small-team-4.png" /></p>
<p>pic 61: Jessica’s topic branch.</p>
<p><code>git fetch origin</code></p>
<p><img alt="small-team-5" src="img/small-team-5.png" /></p>
<p>pic 62: Jessica’s history after fetching John’s changes.</p>
<p><code>git log --no-merges issue54..origin/master</code></p>
<p><code>git checkout master</code></p>
<p><code>git merge issue54</code></p>
<p><code>git merge origin/master</code></p>
<p><img alt="small-team-6" src="img/small-team-6.png" /></p>
<p>pic 63: Jessica’s history after merging John’s changes.</p>
<p><code>git push origin master</code></p>
<p><img alt="small-team-7" src="img/small-team-7.png" /></p>
<p>pic 64: Jessica’s history after pushing all changes back to the server.</p>
<p>Summury</p>
<p><img alt="small-team-flow.png" src="img/small-team-flow.png" /></p>
<p>pic 65: General sequence of events for a simple multiple-developer Git workflow</p>
<h3 id="private-managed-team">Private Managed Team</h3>
<p>integration-manager workflow</p>
<p>Jessica (Server feature A Server feature B)</p>
<p>Let’s follow Jessica’s workflow as she works on her two features, collaborating in parallel with two different developers in this environment. Assuming she already has her repository cloned, she decides to work on featureA first. She creates a new branch for the feature and does some work on it there:</p>
<p>```</p>
<h1 id="jessicas-machine_1">Jessica's Machine</h1>
<p>$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
```</p>
<p>At this point, she needs to share her work with John, so she pushes her featureA branch commits up to the server. Jessica doesn’t have push access to the master branch – only the integrators do – so she has to push to another branch in order to collaborate with John:</p>
<p><code>git push -u origin featureA</code></p>
<p>Jessica decides to start working on featureB with Josie. To begin, she starts a new feature branch, basing it off the server’s master branch:</p>
<p>```</p>
<h1 id="jessicas-machine_2">Jessica's Machine</h1>
<p>$ git fetch origin
$ git checkout -b featureB origin/master
```</p>
<p>Now, Jessica makes a couple of commits on the featureB branch:</p>
<p><code>$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'</code></p>
<p><img alt="managed-team-1" src="img/managed-team-1.png" /></p>
<p>pic 66:  Jessica’s initial commit history.</p>
<p>She’s ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as featureBee. Jessica first needs to merge those changes in with her own before she can push to the server. She can then fetch Josie’s changes down with git fetch: <code>git fetch origin</code></p>
<p><code>git merge origin/featureBee</code></p>
<p><code>git push -u origin featureB:featureBee</code></p>
<p>This is called a refspec. See Спецификации ссылок for a more detailed discussion of Git refspecs and different things you can do with them. Also notice the -u flag; this is short for --set-upstream, which configures the branches for easier pushing and pulling later.</p>
<p>Jessica wants to tweak something, so she commits again and then pushes this back up to the server:</p>
<p><code>$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push</code></p>
<p><img alt="managed-team-2" src="img/managed-team-2.png" /></p>
<p>pic 67: Jessica’s history after committing on a feature branch.</p>
<p>Josie (Server feature A)</p>
<p>John (Server feature B)</p>
<p>Next, John e-mails Jessica to say he’s pushed some changes to the featureA branch and asks her to verify them. She runs a git fetch to pull down those changes: <code>git fetch origin</code></p>
<p>Then, she can see what has been changed with git log: <code>git log featureA..origin/featureA</code>
Finally, she merges John’s work into her own featureA branch:</p>
<p><code>$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA</code></p>
<p>Integrators
essica, Josie, and John inform the integrators that the featureA and featureBee branches on the server are ready for integration into the mainline. After the integrators merge these branches into the mainline, a fetch will bring down the new merge commit, making the history look like this:</p>
<p><img alt="managed-team-3" src="img/managed-team-3.png" /></p>
<p>pic 68: Jessica’s history after merging both her topic branches.</p>
<p>Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process. The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git. The sequence for the workflow you saw here is something like this:</p>
<p><img alt="managed-team-flow" src="img/managed-team-flow.png" /></p>
<p>pic 69: Basic sequence of this managed-team workflow.</p>
<h3 id="forked-public-project">Forked Public Project</h3>
<p>The next section deals with projects that prefer to accept contributed patches via e-mail.</p>
<p>First, you’ll probably want to clone the main repository, create a topic branch for the patch or patch series you’re planning to contribute, and do your work there. The sequence looks basically like this:</p>
<p>```
$ git clone (url)
$ cd project
$ git checkout -b featureA</p>
<h1 id="work">(work)</h1>
<p>$ git commit</p>
<h1 id="work_1">(work)</h1>
<p>$ git commit
```</p>
<blockquote>
<p>You may want to use rebase -i to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review – see Исправление истории for more information about interactive rebasing.</p>
</blockquote>
<p>When your branch work is finished and you’re ready to contribute it back to the maintainers, go to the original project page and click the “Fork” button, creating your own writable fork of the project. You then need to add in this new repository URL as a second remote, in this case named myfork: <code>git remote add myfork (url)</code></p>
<p>Then you need to push your work up to it. It’s easiest to push the topic branch you’re working on up to your repository, rather than merging into your master branch and pushing that up. The reason is that if the work isn’t accepted or is cherry picked, you don’t have to rewind your master branch. If the maintainers merge, rebase, or cherry-pick your work, you’ll eventually get it back via pulling from their repository anyhow: <code>git push -u myfork featureA</code></p>
<p>When your work has been pushed up to your fork, you need to notify the maintainer. This is often called a pull request, and you can either generate it via the website – GitHub has its own Pull Request mechanism that we’ll go over in GitHub – or you can run the git request-pull command and e-mail the output to the project maintainer manually.
The request-pull command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you’re asking to be pulled in. For instance, if Jessica wants to send John a pull request, and she’s done two commits on the topic branch she just pushed up, she can run this: <code>git request-pull origin/master myfork</code></p>
<p>The output can be sent to the maintainer–it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.
On a project for which you’re not the maintainer, it’s generally easier to have a branch like master always track origin/master and to do your work in topic branches that you can easily discard if they’re rejected. Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly. For example, if you want to submit a second topic of work to the project, don’t continue working on the topic branch you just pushed up – start over from the main repository’s master branch: </p>
<p>```
$ git checkout -b featureB origin/master</p>
<h1 id="work_2">(work)</h1>
<p>$ git commit
$ git push myfork featureB</p>
<h1 id="email-maintainer">(email maintainer)</h1>
<p>$ git fetch origin
```</p>
<p><img alt="public-small-1" src="img/public-small-1.png" /></p>
<p>pic 70: Initial commit history with featureB work.</p>
<p>Let’s say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges. In this case, you can try to rebase that branch on top of origin/master, resolve the conflicts for the maintainer, and then resubmit your changes:</p>
<p><code>$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA</code></p>
<p>This rewrites your history to now look like Commit history after featureA work..</p>
<p><img alt="public-small-2" src="public-small-2.png" /></p>
<p>pic 71: Commit history after featureA work</p>
<p>Because you rebased the branch, you have to specify the -f to your push command in order to be able to replace the featureA branch on the server with a commit that isn’t a descendant of it. An alternative would be to push this new work to a different branch on the server (perhaps called featureAv2).
Let’s look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail. You’ll also take this opportunity to move the work to be based off the project’s current master branch. You start a new branch based off the current origin/master branch, squash the featureB changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:</p>
<p>```
$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB</p>
<h1 id="change-implementation">(change implementation)</h1>
<p>$ git commit
$ git push myfork featureBv2
```</p>
<p>The --squash option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you’re on. The --no-commit option tells Git not to automatically record a commit. This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.
Now you can send the maintainer a message that you’ve made the requested changes and they can find those changes in your featureBv2 branch.</p>
<p><img alt="public-small-3" src="img/public-small-3.png" /></p>
<p>pic 72: Commit history after featureBv2 work.</p>
<h3 id="public-project-over-e-mail">Public Project over E-Mail</h3>
<p>Many projects have established procedures for accepting patches – you’ll need to check the specific rules for each project, because they will differ. Since there are several older, larger projects which accept patches via a developer mailing list, we’ll go over an example of that now.
The workflow is similar to the previous use case – you create topic branches for each patch series you work on. The difference is how you submit them to the project. Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:
$ git checkout -b topicA</p>
<h1 id="work_3">(work)</h1>
<p>$ git commit</p>
<h1 id="work_4">(work)</h1>
<p>$ git commit
Now you have two commits that you want to send to the mailing list. You use git format-patch to generate the mbox-formatted files that you can e-mail to the list – it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body. The nice thing about this is that applying a patch from an e-mail generated with format-patch preserves all the commit information properly.
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
The format-patch command prints out the names of the patch files it creates. The -M switch tells Git to look for renames. The files end up looking like this:</p>
<p>```
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function</p>
<p>Limit log functionality to the first 20</p>
<hr />
<p>lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)</p>
<p>diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end</p>
<p>def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end</p>
<h2 id="def-ls_treetreeish-master">def ls_tree(treeish = 'master')</h2>
<p>2.1.0
```</p>
<p>You can also edit these patch files to add more information for the e-mail list that you don’t want to show up in the commit message. If you add text between the --- line and the beginning of the patch (the diff --git line), then developers can read it; but applying the patch excludes it.
To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program. Pasting the text often causes formatting issues, especially with “smarter” clients that don’t preserve newlines and other whitespace appropriately. Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you. We’ll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned Documentation/SubmittingPatches file in the Git source code.
First, you need to set up the imap section in your ~/.gitconfig file. You can set each value separately with a series of git config commands, or you can add them manually, but in the end your config file should look something like this:
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
If your IMAP server doesn’t use SSL, the last two lines probably aren’t necessary, and the host value will be imap:// instead of imaps://. When that is set up, you can use git send-email to place the patch series in the Drafts folder of the specified IMAP server:
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a>]
Emails will be sent from: Jessica Smith <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
Then, Git spits out a bunch of log information looking something like this for each patch you’re sending:
(mbox) Adding cc: Jessica Smith <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a> from
  \line 'From: Jessica Smith <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#49;&#50;&#52;&#51;&#55;&#49;&#53;&#51;&#53;&#54;&#45;&#54;&#49;&#55;&#50;&#54;&#45;&#49;&#45;&#103;&#105;&#116;&#45;&#115;&#101;&#110;&#100;&#45;&#101;&#109;&#97;&#105;&#108;&#45;&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#49;&#50;&#52;&#51;&#55;&#49;&#53;&#51;&#53;&#54;&#45;&#54;&#49;&#55;&#50;&#54;&#45;&#49;&#45;&#103;&#105;&#116;&#45;&#115;&#101;&#110;&#100;&#45;&#101;&#109;&#97;&#105;&#108;&#45;&#106;&#101;&#115;&#115;&#105;&#99;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y></p>
<p>Result: OK
At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you’re sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.</p>
<h3 id="maintaining-a-project">Maintaining a Project</h3>
</body></html>